<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>HTML5+CSS301-day01</title>
    <url>/posts/10501.html</url>
    <content><![CDATA[<p>第一天笔记<br><span id="more"></span></p>
<h3 id="HTML定义"><a href="#HTML定义" class="headerlink" title="HTML定义"></a>HTML定义</h3><p>HTML超文本标记语言―—HyperText Markup Language。</p>
<ul>
<li>超文本是什么?         链接</li>
<li>标记是什么?         标记也叫标签，带尖括号的文本</li>
</ul>
<h3 id="标签语法"><a href="#标签语法" class="headerlink" title="标签语法"></a>标签语法</h3><ul>
<li><p>标签成对出现，中间包裹内容</p>
</li>
<li><p>&lt;&gt;里面放英文字母(标签名)</p>
</li>
<li><p>结束标签比开始标签多/</p>
</li>
<li>拓展<ul>
<li>双标签:成对出现的标签</li>
<li>单标签:只有开始标签，没有结束标签</li>
</ul>
</li>
</ul>
<h3 id="基本骨架"><a href="#基本骨架" class="headerlink" title="基本骨架"></a>基本骨架</h3><ul>
<li>html:整个网页</li>
<li>head:网页头部，用来存放给浏览器看的信息，例如CSS<ul>
<li>title:网页标题</li>
</ul>
</li>
<li>body:网页主体，用来存放给用户看的信息，例如图片、文字</li>
</ul>
<h3 id="标签的关系"><a href="#标签的关系" class="headerlink" title="标签的关系"></a>标签的关系</h3><p>作用：明确标签的书写位置;让代码格式更整齐</p>
<ul>
<li>父子关系（嵌套关系)</li>
<li>兄弟关系（并列关系)</li>
<li>*代码格式</li>
<li>父子关系：子级标签换行且缩进(Tab键)</li>
<li>兄弟关系：兄弟标签换行要对齐</li>
</ul>
<h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 注释--&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="排版标签，标题和段落"><a href="#排版标签，标题和段落" class="headerlink" title="排版标签，标题和段落"></a>排版标签，标题和段落</h3><h4 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h4><p>一般用在新闻标题、文章标题、网页区域名称、产品名称等等。</p>
<p>标签名: h1 ~h6（双标签）</p>
<p>显示特点：</p>
<ul>
<li>文字加粗</li>
<li>字号逐渐减小</li>
<li>独占一行（换行）</li>
</ul>
<p>经验分享：</p>
<ul>
<li>h1标签在一个网页中只能用一次</li>
<li>用来放新闻标题或网页的logo. h2~ h6没有使用次数的限制</li>
</ul>
<h4 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h4><p>一般用在新闻段落、文章段落、产品描述信息等等。</p>
<p>标签名: p（双标签）</p>
<p>显示特点：</p>
<ul>
<li>独占一行</li>
<li>段落之间存在间隙</li>
</ul>
<h3 id="换行和水平线标签"><a href="#换行和水平线标签" class="headerlink" title="换行和水平线标签"></a>换行和水平线标签</h3><ul>
<li>换行标签 \<br> （单标签）</li>
<li>水平线标签 \<hr> （单标签）</li>
</ul>
<h3 id="文本格式化标签"><a href="#文本格式化标签" class="headerlink" title="文本格式化标签"></a>文本格式化标签</h3><p>作用：为文本添加特殊格式，以突出重点。常见的文本格式</p>
<ul>
<li><strong>加粗</strong></li>
<li><em>倾斜</em></li>
<li><ins>下划线</ins></li>
<li><del>删除线</del></li>
<li>等等</li>
</ul>
<div class="table-container">
<table>
<thead>
<tr>
<th>标签名</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>\<strong>\</strong></td>
<td>加粗</td>
</tr>
<tr>
<td>\<em>\</em></td>
<td>倾斜</td>
</tr>
<tr>
<td>\<ins>\</ins></td>
<td>下划线</td>
</tr>
<tr>
<td>\<del>\</del></td>
<td>删除线</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>标签名</th>
<th>效果</th>
</tr>
</thead>
<tbody>
<tr>
<td>b</td>
<td>加错</td>
</tr>
<tr>
<td>i</td>
<td>倾斜</td>
</tr>
<tr>
<td>u</td>
<td>下划线</td>
</tr>
<tr>
<td>s</td>
<td>删除线</td>
</tr>
</tbody>
</table>
</div>
<p><strong>strong、em、ins、 del标签自带强调含义（语义），一般使用这一套</strong></p>
<p><strong>两个文本格式化标签是在一行显示</strong></p>
<h3 id="图像标签"><a href="#图像标签" class="headerlink" title="图像标签"></a>图像标签</h3><p>作用：在网页中插入图片。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;图片的url&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>src用于指定图像的位置和名称，是\<img>的必须属性。</p>
<p>标签属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>属性</th>
<th>作用</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>alt</td>
<td>替换文本</td>
<td>图片无法显示时显示的文字</td>
</tr>
<tr>
<td>title</td>
<td>提示文本</td>
<td>鼠标悬停在图片上时显示的文字</td>
</tr>
<tr>
<td>width</td>
<td>图片的宽度</td>
<td>值为数字，没有单位</td>
</tr>
<tr>
<td>height</td>
<td>图片的高度</td>
<td>值为数字，没有单位</td>
</tr>
</tbody>
</table>
</div>
<ul>
<li>属性名=”属性值”</li>
<li>属性写在尖括号里面，标签名后面，标签名和属性之间用空格隔开，不区分先后顺序</li>
</ul>
<h3 id="文件路径"><a href="#文件路径" class="headerlink" title="文件路径"></a>文件路径</h3><p>路径分类：</p>
<ul>
<li>相对路径：从当前文件位置出发查找目标文件</li>
<li>绝对路径：从盘符出发查找目标文件</li>
</ul>
<p>相对路径写法：</p>
<ul>
<li>. 当前文件所在文件夹</li>
<li>../ 当前文件上一级文件夹</li>
<li>/ 进入某个文件夹里面</li>
</ul>
<p>绝对路径写法：</p>
<p>Windows 默认是\，其他系统是/，建议统一写为/</p>
<h3 id="超链接标签"><a href="#超链接标签" class="headerlink" title="超链接标签"></a>超链接标签</h3><p>作用：点击跳转到其他页面。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;网址&quot;</span>&gt;</span>跳转到网址<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：属性 target=”_blank” 表示新窗口跳转页面</strong></p>
<p>经验分享：开发初期，不知道超链接的跳转地址，href属性值写#，表示空链接，不会跳转</p>
<h3 id="音频标签"><a href="#音频标签" class="headerlink" title="音频标签"></a>音频标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;音频的url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>常见属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">特殊说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">src（必须属性）</td>
<td style="text-align:center">音频URL</td>
<td style="text-align:center">支持格式：MP3、Ogg、Wav</td>
</tr>
<tr>
<td style="text-align:center">controls</td>
<td style="text-align:center">展示音频控制面板</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">loop</td>
<td style="text-align:center">循环播放</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">autoplay</td>
<td style="text-align:center">自动播放</td>
<td style="text-align:center">为了提升用户体验，浏览器一般会禁用自动播放</td>
</tr>
</tbody>
</table>
</div>
<p>简写：属性名和属性值一样，可以进行简写，例如</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;音频的url&quot;</span> <span class="attr">controls</span>=<span class="string">&quot;controls&quot;</span> <span class="attr">loop</span>=<span class="string">&quot;loop&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 简写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">audio</span> <span class="attr">src</span>=<span class="string">&quot;音频的url&quot;</span> <span class="attr">contrils</span> <span class="attr">loop</span>&gt;</span><span class="tag">&lt;/<span class="name">audio</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="视频标签"><a href="#视频标签" class="headerlink" title="视频标签"></a>视频标签</h3><figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">video</span> <span class="attr">src</span>=<span class="string">&quot;视频的url&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">video</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>常见属性</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">特殊说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">src（必须属性）</td>
<td style="text-align:center">视频URL</td>
<td style="text-align:center">支持格式：MP4、WebM、Ogg</td>
</tr>
<tr>
<td style="text-align:center">controls</td>
<td style="text-align:center">展示音频控制面板</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">loop</td>
<td style="text-align:center">循环播放</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">muted</td>
<td style="text-align:center">静音播放</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">autoplay</td>
<td style="text-align:center">自动播放</td>
<td style="text-align:center">为了提升用户体验，浏览器支持在静音模式下自动播放</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5+CSS301-day02</title>
    <url>/posts/10502.html</url>
    <content><![CDATA[<p>第二天笔记<br><span id="more"></span></p>
<h3 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h3><p>作用：布局内容排列整齐的区域。</p>
<h4 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h4><p>作用：布局排列整齐的不需要规定顺序的区域。</p>
<p>标签：ul嵌套li，ul是无序列表，li是列表条目。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>ul标签里面只能包裹li标签</li>
<li>li标签里面可以包裹任何内容</li>
</ul>
<h4 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h4><p>作用：布局排列整齐的需要规定顺序的区域。</p>
<p>标签：ol嵌套li，ol是有序列表，li是列表条目。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第三项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>ol标签里面只能包裹li标签</li>
<li>li标签里面可以包裹任何内容</li>
</ul>
<h4 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h4><p>标签：dl嵌套dt和dd，dl是定义列表，dt是定义列表的标题，dd是定义列表的描述/详情。</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dt</span>&gt;</span>列表标题<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">	<span class="tag">&lt;<span class="name">dd</span>&gt;</span>列表描述/详情<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">    ......</span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li>dl标签里面只能包裹li标签</li>
<li>dt和dd标签里面可以包裹任何内容</li>
</ul>
<h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><h4 id="表格标签"><a href="#表格标签" class="headerlink" title="表格标签"></a>表格标签</h4><p>网页中的表格与Excel表格类似，用来展示数据。</p>
<p>标签:table嵌套tr，tr嵌套td / th。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标签名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>table</td>
<td>表格</td>
</tr>
<tr>
<td>tr</td>
<td>行</td>
</tr>
<tr>
<td>td</td>
<td>表头单元格</td>
</tr>
<tr>
<td>th</td>
<td>内容单元格</td>
</tr>
</tbody>
</table>
</div>
<p>提示：在网页中，表格默认没有边框线，使用border属性可以为表格添加边框线。</p>
<h4 id="表格结构标签"><a href="#表格结构标签" class="headerlink" title="表格结构标签"></a>表格结构标签</h4><p>作用：用表格结构标签把内容划分区域，让表格结构更清晰，语义更清晰。</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>标签名</th>
<th>含义</th>
<th>特殊说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>thead</td>
<td>表格头部</td>
<td>表格头部内容</td>
</tr>
<tr>
<td>tbody</td>
<td>表格主体</td>
<td>主要内容区域</td>
</tr>
<tr>
<td>tfoot</td>
<td>表格底部</td>
<td>汇总信息区域</td>
</tr>
</tbody>
</table>
</div>
<h4 id="合并单元格"><a href="#合并单元格" class="headerlink" title="合并单元格"></a>合并单元格</h4><p>作用：将多个单元格合并成一个单元格，以合并同类信息</p>
<p>跨行合并<br>跨列合并</p>
<p>合并单元格的步骤：</p>
<p>1．明确合并的目标</p>
<p>2．保留<strong>最左最上</strong>的单元格，添加属性（<strong>取值是数字，表示需要合并的单元格数量</strong>）</p>
<ul>
<li>跨行合并，保留<strong>最上</strong>单元格，添加属性<strong>rowspan</strong></li>
<li>跨列合并，保留<strong>最左</strong>单元格，添加属性<strong>colspan</strong></li>
</ul>
<p>3．删除其他单元格</p>
<h3 id="表单"><a href="#表单" class="headerlink" title="表单"></a>表单</h3>]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML5+CSS3总览</title>
    <url>/posts/10500.html</url>
    <content><![CDATA[<h3 id="HTML5-CSS301-day01"><a href="#HTML5-CSS301-day01" class="headerlink" title="HTML5+CSS301-day01"></a>HTML5+CSS301-day01</h3><p><a href="https://wang-nine.cn/posts/10501.html">HTML5+CSS301-day01</a></p>
<h3 id="HTML5-CSS301-day02"><a href="#HTML5-CSS301-day02" class="headerlink" title="HTML5+CSS301-day02"></a>HTML5+CSS301-day02</h3><p><a href="https://wang-nine.cn/posts/10502.html">HTML5+CSS301-day01</a></p>
]]></content>
      <categories>
        <category>HTML+CSS</category>
      </categories>
      <tags>
        <tag>HTML+CSS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo+Butterfly主题博客搭建01</title>
    <url>/posts/10001.html</url>
    <content><![CDATA[<p>Hexo+Butterfly主题博客搭建01 ——— 个人博客搭建的基础环境配置工作<br><span id="more"></span></p>
<h3 id="Node-js的配置"><a href="#Node-js的配置" class="headerlink" title="Node.js的配置"></a>Node.js的配置</h3><p><a href="https://nodejs.org/en/download">nodejs的官网</a></p>
<p>选择适合自己系统的下载即可，大部分人应该是Windows Installer (.msi) 64位，选择msi位安装程序，mac和linux用户选择适合自己的版本即可。</p>
<p>安装是一路默认选项即可，<strong>注意安装的路径可以根据自己的需求，一定要记住安装在哪里了</strong></p>
<p>安装完成之后可以在cmd中测试是否安装成功</p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm -v</span><br></pre></td></tr></table></figure>
<p><img src="https://wang-nine.cn/images/Hexo01-01%E6%9F%A5%E7%9C%8Bnode%E6%98%AF%E5%90%A6%E5%AE%89%E8%A3%85%E6%88%90%E5%8A%9F.png" alt="Hexo01-01查看node是否安装成功"></p>
<h3 id="Git的配置"><a href="#Git的配置" class="headerlink" title="Git的配置"></a>Git的配置</h3><p><a href="https://git-scm.com/">Git的官网</a></p>
<p><img src="https://wang-nine.cn/images/Hexo01-02Git%E5%AE%89%E8%A3%85-1.png" alt="Hexo01-02Git安装-1"></p>
<p>选择适合自己系统的下载即可，大部分人应该是Windows64位，所以直接点击Downloade for Windows即可。</p>
<p>安装是一路默认选项即可，<strong>注意安装的路径可以根据自己的需求，一定要记住安装在哪里了</strong></p>
<p>安装完成之后可以在cmd中测试是否安装成功</p>
<h3 id="github的配置"><a href="#github的配置" class="headerlink" title="github的配置"></a>github的配置</h3><p>在github新建一个仓库</p>
<blockquote>
<p>名称为 <strong>你的名称.github.io</strong></p>
</blockquote>
<p>如图所示为我的仓库样例：</p>
<p><img src="https://wang-nine.cn/images/Hexo01-03github%E7%9A%84%E9%85%8D%E7%BD%AE.png" alt="Hexo01-03github的配置"></p>
<h3 id="博客的初始化"><a href="#博客的初始化" class="headerlink" title="博客的初始化"></a>博客的初始化</h3><h4 id="安装Hexo"><a href="#安装Hexo" class="headerlink" title="安装Hexo"></a>安装Hexo</h4><p>所有必备的应用程序安装完成后，即可使用<code>npm</code>安装<code>Hexo</code>。不要觉得安装这个框架有多复杂，只需要一条命令就可以了。<code>npm</code>是安装工具，<code>install</code>表示安装，<code>-g</code>表示全局安装，<code>hexo-cli</code>表示安装的是hexo框架。</p>
<p>在 git 命令行下输入下述的命令，<strong>若无法安装可能是因为权限不够，可以以管理员权限运行 gitbash</strong></p>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install -g hexo-cli</span><br></pre></td></tr></table></figure>
<h4 id="初始化博客"><a href="#初始化博客" class="headerlink" title="初始化博客"></a>初始化博客</h4><p>安装完框架之后新建一个存放博客的文件夹Blog，这里在D盘新建了一个Blog文件夹，在该文件夹下右键Git Bash Here并输入<code>hexo init</code>命令初始化这个文件夹。注意新建 Blog 文件夹和初始化这个文件夹只需要下面这条命令就可以了。</p>
<h4 id="启动和配置博客"><a href="#启动和配置博客" class="headerlink" title="启动和配置博客"></a>启动和配置博客</h4><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">hexo clean  # 清除缓存</span><br><span class="line">hexo g      # 生成静态网页</span><br><span class="line">hexo d      # 部署到Github</span><br><span class="line">hexo s 		# 是 hexo server 的缩写，启动本地服务器，用于预览主题。默认地址： http://localhost:4000/</span><br></pre></td></tr></table></figure>
<p>此时输入 <code>hexo clean</code>  <code>hexo d</code>  <code>hexo h</code>  <code>hexo s</code> 命令即可初步查看自己的 Blog 页面<br>在浏览器输入 <a href="http://localhost:4000/">http://localhost:4000/</a> 即可访问<br>顺利的话，在浏览器输入：<code>用户名.github.io</code> 即可初步访问自己的博客</p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Butterfly主题博客搭建02</title>
    <url>/posts/10002.html</url>
    <content><![CDATA[<p>Hexo+Butterfly主题博客搭建02 ——— 下载有关butterfly主题并进行配置<br><span id="more"></span></p>
<h3 id="Butterfly主题的安装"><a href="#Butterfly主题的安装" class="headerlink" title="Butterfly主题的安装"></a>Butterfly主题的安装</h3><ol>
<li>在 hexo 项目根目录下执行操作clone主题</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">git clone -b master https://github.com/jerryc127/hexo-theme-butterfly.git themes/butterfly</span><br></pre></td></tr></table></figure>
<ol>
<li>如果沒有 pug 以及 <a href="https://so.csdn.net/so/search?q=stylus&amp;spm=1001.2101.3001.7020">stylus</a> 的渲染器，还需要下载，否则在项目运行时会报错：</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line">npm install hexo-renderer-pug hexo-renderer-stylus --save</span><br></pre></td></tr></table></figure>
<ol>
<li>修改项目根目录下的_config.yml文件（称为站点配置文件），开启主题</li>
</ol>
<figure class="highlight text"><table><tr><td class="code"><pre><span class="line"># Extensions</span><br><span class="line">## Plugins: https://hexo.io/plugins/</span><br><span class="line">## Themes: https://hexo.io/themes/</span><br><span class="line">#theme: landscape</span><br><span class="line">theme: butterfly</span><br></pre></td></tr></table></figure>
<ol>
<li>升级建议</li>
</ol>
<p>为了減少升级主题带来的不便，我们还需要做以下操作：<br>把主题文件夹中的 _config.yml 复制到 Hexo 根目录下，同重命名为 _config.butterfly.yml</p>
<p>Hexo会自动合并主题中的  _config.yml  和   _config.butterfly.yml  里的配置，如果存在同名配置，会使用  _config.butterfly.yml  的配置，其优先度较高。</p>
<h3 id="ButterFly主题"><a href="#ButterFly主题" class="headerlink" title="ButterFly主题"></a>ButterFly主题</h3>]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>Hexo-Butterfly主题博客搭建03</title>
    <url>/posts/10003.html</url>
    <content><![CDATA[]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>JavaSE02-Java中的文件与方法递归与IO流</title>
    <url>/posts/10101.html</url>
    <content><![CDATA[<p>详细的描述了Java中 File类的使用，一步一步剖析了IO流如何创建、如何使用以及其中的注意事项。</p>
<p>File类使用：详细的描述了使用File的对象操作文件，如:删除、获取文件信息、创建文件夹等<br>方法递归：详细的描述了递归算法思想并能完成常见递归题目，以及文件搜索<br>字符集：程序中经常要读取文件中的数据，知道数据的底层形式才能够去学习如何读写数据<br>IO流的作用：使用IO流完成文件数据的读写等操作<br>字节流与字符流：数据的类型很多，要学会选择不同的流进行读写操作<br><span id="more"></span></p>
<p><img src="C:/Users/Wang/AppData/Roaming/Typora/typora-user-images/image-20230524214623406.png" alt="image-20230524214623406"></p>
<h2 id="File"><a href="#File" class="headerlink" title="File"></a>File</h2><p><strong>File类在包java.io.File下、代表操作系统的文件对象（文件、文件夹）。</strong><br><strong>File类提供了诸如∶定位文件，获取文件本身的信息、删除文件、创建文件（文件夹）等功能</strong><br><strong>但是不能读写文件内容。</strong></p>
<p>File类创建对象API</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public File(String pathname)</td>
<td>根据文件路径创建文件对象</td>
</tr>
<tr>
<td>public File(String parent, String child)</td>
<td>从父路径名字符串和子路径名字符串创建文件对象</td>
</tr>
<tr>
<td>public File(File parent, String child)</td>
<td>根据父路径对应文件对象和子路径名字符串创建文件对象</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title>Java中的多线程</title>
    <url>/posts/10100.html</url>
    <content><![CDATA[<p>详细的描述了Java中多线程的创建、使用、同步问题，以及线程池的创建、使用问题，详细的描述了定时器的创建和使用，详细的分析了Java中六种不同的线程转态以及转换。<br><span id="more"></span></p>
<h2 id="1-Java中的多线程创建"><a href="#1-Java中的多线程创建" class="headerlink" title="1.Java中的多线程创建"></a>1.Java中的多线程创建</h2><big> **java中多线程的创建可以分为三种不同的形式：**</big>

<h3 id="①-继承Thread类"><a href="#①-继承Thread类" class="headerlink" title="① 继承Thread类"></a>① 继承Thread类</h3><p><strong>具体步骤：</strong></p>
<blockquote>
<p>1.定义一个类MyThread继承<br>2.创建MyThread对象<br>3.调用线程对象的start方法启动线程（启动后会自动执行MyThread中重写的run()方法）<br>具体的例子如下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3.new一个线程对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>();</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4.调用start()方法执行线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.定义一个线程类继承Thread</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.重写run方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：</strong><br><strong>1.为什么不直接调用run方法，而是调用start启动线程</strong><br><strong>答：直接调用run方法会当成普通方法执行，此时还是相当于单线程执行。</strong><br><strong>2.为什么主线程任务放在子线程之后？</strong><br><strong>答：否则会先执行主线程任务再执行子线程任务。</strong></p>
<p><strong>优缺点：</strong><br><strong>优点：编程简单</strong><br><strong>缺点：单继承的局限性，不能继承其他类，不便于扩展。</strong></p>
</blockquote>
<h3 id="②-实现Runnable接口"><a href="#②-实现Runnable接口" class="headerlink" title="② 实现Runnable接口"></a>② 实现Runnable接口</h3><p><strong>具体步骤：</strong></p>
<blockquote>
<p>1.定义一个线程任务类MyRunnable实现Runnable接口，重写run方法<br>2.创建MyRunnable对象<br>3.把MyRunnable对象交给Thread处理<br>具体的例子如下</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2.创建MyRunnable对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3.把MyRunnable对象交给Thread处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(target);</span><br><span class="line">        t.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;主线程执行输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.定义一个线程任务类MyRunnable实现Runnable接口，重写run方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;子线程执行输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优缺点：<br>优点：扩展性强，可以继续继承和实现。<br>缺点：如果线程有执行结果不能直接返回。</p>
<p>注意：也可通过匿名内部类实现（建议的写法）</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过匿名内部类来实现</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">new</span> <span class="title class_">Thread</span>(<span class="keyword">new</span> <span class="title class_">MyRunnable</span>() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;匿名内部类子线程的输出&quot;</span> + i);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;).start();</span><br></pre></td></tr></table></figure>
<h3 id="③-实现Callable接口，通过FutureTask接口接收返回值（JDK5新增）"><a href="#③-实现Callable接口，通过FutureTask接口接收返回值（JDK5新增）" class="headerlink" title="③ 实现Callable接口，通过FutureTask接口接收返回值（JDK5新增）"></a>③ 实现Callable接口，通过FutureTask接口接收返回值（JDK5新增）</h3><blockquote>
<p>1.得到任务对象<br>    第一步：定义一个线程任务类MyCallable实现Callable接口，重写call方法，该方法可以返回结果<br>    第二步：用Future吧Callable对象封装成线程任务对象<br>2.把线程任务对象交给Thread处理<br>3.调用Thread的start方法启动任务<br>4.线程执行完毕后，通过FutureTask的get方法获得结果</p>
</blockquote>
<p>具体的例子如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 3.创建任务对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Callable&lt;String&gt; call1 = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 4.把Callable任务对象交给FutureTask对象</span></span><br><span class="line"><span class="comment">         * FutureTask的作用1：FutureTask实现了Runnable接口，此时就可以交给Thread了</span></span><br><span class="line"><span class="comment">         * FutureTask的作用2：可以在线程执行完毕后调用get方法得到线程执行的结果</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//Thread t = new Thread(call);  报错，Thread不能接收call对象</span></span><br><span class="line">        FutureTask&lt;String&gt; f1 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 5.交给线程处理</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f1);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 6.启动线程</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        t1.start();</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        Callable&lt;String&gt; call2 = <span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>);</span><br><span class="line">        FutureTask&lt;String&gt; f2 = <span class="keyword">new</span> <span class="title class_">FutureTask</span>&lt;&gt;(call2);</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Thread</span>(f2);</span><br><span class="line">        t2.start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs1</span> <span class="operator">=</span> f1.get();   <span class="comment">//直接调用call方法，可能还没有执行完，使用get时若发现线程未执行完会先等线程执行完毕</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第一个结果为：&quot;</span> + rs1);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">           e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">rs2</span> <span class="operator">=</span> f2.get();   <span class="comment">//直接调用call方法，可能还没有执行完，使用get时若发现线程未执行完会先等线程执行完毕</span></span><br><span class="line">            System.out.println(<span class="string">&quot;第二个结果为：&quot;</span> + rs2);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 1.定义一个实现类，实现Callable接口，记得声明结果的数据类型</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">MyCallable</span> <span class="keyword">implements</span> <span class="title class_">Callable</span>&lt;String&gt; &#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 2.重写call方法</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyCallable</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.n = n;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            sum += i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;子线程执行的结果是&quot;</span> + sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>优缺点：<br>优点：扩展性强，可以继续继承和实现。<br>     可以在线程执行完毕后获取线程执行的结果。<br>缺点：编程较为复杂。</p>
<p>注意：Callable 与 FutureTask 创建对象时都需要声明类型</p>
</blockquote>
<h2 id="2-Java中的多线程常用方法"><a href="#2-Java中的多线程常用方法" class="headerlink" title="2.Java中的多线程常用方法"></a>2.Java中的多线程常用方法</h2><h3 id="①-线程名称有关的方法"><a href="#①-线程名称有关的方法" class="headerlink" title="① 线程名称有关的方法"></a>① 线程名称有关的方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void setName()</td>
<td>设置线程名称</td>
</tr>
<tr>
<td>String getName(String name)</td>
<td>获得线程名称</td>
</tr>
<tr>
<td>CuurentThread()</td>
<td>获取当前的线程对象，哪个线程执行，拿到哪个线程对象</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>也可在构造器中取名</th>
</tr>
</thead>
<tbody>
<tr>
<td>public Thread(String name)</td>
</tr>
<tr>
<td>public Thread(Runnable target)</td>
</tr>
<tr>
<td>public Thread(Runnable target, String name)</td>
</tr>
</tbody>
</table>
</div>
<h3 id="②-线程休眠有关的方法"><a href="#②-线程休眠有关的方法" class="headerlink" title="② 线程休眠有关的方法"></a>② 线程休眠有关的方法</h3><div class="table-container">
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>sleep(long time)</td>
<td>单位为ms</td>
</tr>
</tbody>
</table>
</div>
<p>具体的例子如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;一号线程&quot;</span>);</span><br><span class="line">        t1.start();</span><br><span class="line"><span class="comment">//        t1.setName(&quot;一号线程&quot;);</span></span><br><span class="line">        System.out.println(t1.getName());</span><br><span class="line"></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">t2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyThread</span>(<span class="string">&quot;二号线程&quot;</span>);</span><br><span class="line">        t2.start();</span><br><span class="line"><span class="comment">//        t2.setName(&quot;二号线程&quot;);</span></span><br><span class="line">        System.out.println(t2.getName());</span><br><span class="line"></span><br><span class="line">        <span class="comment">//哪个线程执行，拿到哪个线程对象</span></span><br><span class="line">        <span class="type">Thread</span> <span class="variable">m</span> <span class="operator">=</span> Thread.currentThread();</span><br><span class="line">        System.out.println(m.getName());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(<span class="string">&quot;Main线程输出&quot;</span> + i);</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">3</span>)</span><br><span class="line">                Thread.sleep(<span class="number">3</span> * <span class="number">1000</span>); <span class="comment">//主线程休眠3000ms</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程的子类，自定义的线程MyThread<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MyThread</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="comment">//让父类的构造器进行构造</span></span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>; i &lt;= <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;输出&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="3-Java中的线程安全问题"><a href="#3-Java中的线程安全问题" class="headerlink" title="3.Java中的线程安全问题"></a>3.Java中的线程安全问题</h2><h3 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h3><p><strong><big>多个线程同时操作一个共享资源可能会出现业务安全问题，称为线程安全问题</big></strong></p>
<p>例如小明和小红有一个共同账户，余额为10万元，模拟两人同时取钱10万元<br>基础的定义代码如下：</p>
<p> <strong>① 提供一个账户类，创建一个账户对象代表两个人的共享账户</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;   <span class="comment">//余额</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DrawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName(); <span class="comment">//获取取钱人的姓名</span></span><br><span class="line">        <span class="comment">//1.判断账户中的钱是否足够</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">            <span class="comment">//2.取钱</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱成功，吐出：&quot;</span> + money);</span><br><span class="line">            <span class="comment">//3.更新余额</span></span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(<span class="string">&quot;取钱后剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4.余额不足</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> cardId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> cardId</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 设置</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toString</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Account&#123;cardId = &quot;</span> + cardId + <span class="string">&quot;, money = &quot;</span> + money + <span class="string">&quot;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>② 定义一个线程类，用来处理账户对象</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取钱的线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Account acc;    <span class="comment">//定义一个账户对象，便于对账户对象进行操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account acc, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        acc.DrawMoney(<span class="number">100000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>③ 创建两个线程对象，传入同一个账户对象</strong></p>
<p><strong>④ 启动两个线程，去同一个账户对象中取钱10万</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟取钱案例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.定义线程类，创建一个共享的账户对象</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-999&quot;</span>, <span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 2.创建两个线程对象，代表小明和小红同时取钱</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意会出现下面的错误样例：</p>
<p><img src="https://wang-nine.cn/images/JavaSE01-01%E9%94%99%E8%AF%AF%E6%A0%B7%E4%BE%8B.png" alt="JavaSE01-01错误样例"></p>
<h3 id="解决方法：线程同步"><a href="#解决方法：线程同步" class="headerlink" title="解决方法：线程同步"></a>解决方法：线程同步</h3><p><strong>针对上述错误解决线程安全问题：线程同步（同一个时刻仅有一个线程可以访问共享资源）</strong></p>
<h4 id="①-同步代码块"><a href="#①-同步代码块" class="headerlink" title="① 同步代码块"></a>① 同步代码块</h4><p>synchorized(同步锁对象) {<br>    操作共享资源的代码（核心代码）<br>}</p>
<blockquote>
<p><strong>注意：同步锁对象对于不同的对象来说唯一即可，同一时间只能被一个人占用，因此可以使用字符串为同步锁对象，字符串在常量池中</strong><br><strong>注意：上述同步锁对象对于小明小红唯一，但是若有小黑小白另一家庭取钱，此时也会等待，此时会出问题。</strong><br><strong>锁对象使用任意的唯一对象可以吗？</strong><br><strong>答：不可以，会影响其他无关线程的执行。</strong><br><strong>锁对象的规范要求：使用共享资源作为锁对象</strong><br>               <strong>因此：对于实例方法：使用this作为锁对象</strong><br>                           <strong>对于静态方法：使用字节码（类名.class)作为锁对象</strong></p>
</blockquote>
<p>实例代码如下(修改了上述的代码之后，结果正确)</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DrawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName(); <span class="comment">//获取取钱人的姓名</span></span><br><span class="line">    <span class="comment">//同步代码块</span></span><br><span class="line">    <span class="keyword">synchronized</span> (<span class="built_in">this</span>) &#123;</span><br><span class="line">        <span class="comment">//1.判断账户中的钱是否足够</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">            <span class="comment">//2.取钱</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱成功，吐出：&quot;</span> + money);</span><br><span class="line">            <span class="comment">//3.更新余额</span></span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(<span class="string">&quot;取钱后剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4.余额不足</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结果如下：</p>
<p><img src="https://wang-nine.cn/images/JavaSE01-02%E6%AD%A3%E7%A1%AE%E6%A0%B7%E4%BE%8B.png" alt="JavaSE02-正确样例"></p>
<h4 id="②-同步方法"><a href="#②-同步方法" class="headerlink" title="② 同步方法"></a>② 同步方法</h4><p>修饰符 synchorized 返回值类型 方法名称(形参列表) {<br>    操作共享资源的代码（核心代码）<br>}</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">DrawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;     <span class="comment">//同步方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName(); <span class="comment">//获取取钱人的姓名</span></span><br><span class="line">    <span class="comment">//1.判断账户中的钱是否足够</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">        <span class="comment">//2.取钱</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱成功，吐出：&quot;</span> + money);</span><br><span class="line">        <span class="comment">//3.更新余额</span></span><br><span class="line">        <span class="built_in">this</span>.money -= money;</span><br><span class="line">        System.out.println(<span class="string">&quot;取钱后剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//4.余额不足</span></span><br><span class="line">        System.out.println(name + <span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>注意：同步方法底层也有锁对象，为隐式锁对象，锁的范围是整个方法代码</strong><br><strong>如果方法是实例方法，会用this作为同步锁对象</strong><br><strong>如果方法是静态方法，会用类名.class作为同步锁对象</strong></p>
<p><strong>注意，上述两种方法中，同步代码块性能较好，范围越小性能越好，相当于一个在厕所外面排队，一个在坑外面排队，但是同步方法更好些更直观，在实际应用中多数使用同步方法</strong></p>
</blockquote>
<h4 id="③-同步锁（JDK5后提供了新的锁对象Lock，更加的灵活方便）"><a href="#③-同步锁（JDK5后提供了新的锁对象Lock，更加的灵活方便）" class="headerlink" title="③ 同步锁（JDK5后提供了新的锁对象Lock，更加的灵活方便）"></a>③ 同步锁（JDK5后提供了新的锁对象Lock，更加的灵活方便）</h4><p><strong>Lock是接口，采用实现类ReentrantLock来构建Lock锁对象</strong></p>
<p><strong>常用api如下</strong></p>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public ReentrantLock()</td>
<td>获得Lock锁的实现类对象</td>
</tr>
<tr>
<td>void lock()</td>
<td>获得锁</td>
</tr>
<tr>
<td>void unlock()</td>
<td>释放锁</td>
</tr>
</tbody>
</table>
</div>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//用final修饰，锁对象是唯一且不可替换的</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="type">Lock</span> <span class="variable">lock</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ReentrantLock</span>();</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">DrawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;     <span class="comment">//同步方法</span></span><br><span class="line">    <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName(); <span class="comment">//获取取钱人的姓名</span></span><br><span class="line">    <span class="comment">//1.判断账户中的钱是否足够</span></span><br><span class="line">    lock.lock();    <span class="comment">//上锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">            <span class="comment">//2.取钱</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱成功，吐出：&quot;</span> + money);</span><br><span class="line">            <span class="comment">//3.更新余额</span></span><br><span class="line">            <span class="built_in">this</span>.money -= money;</span><br><span class="line">            System.out.println(<span class="string">&quot;取钱后剩余：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//4.余额不足</span></span><br><span class="line">            System.out.println(name + <span class="string">&quot;来取钱，余额不足！&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();  <span class="comment">//解锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意：一、锁对象声明为final代表锁是唯一且不可替换的</strong><br>            <strong>二、unlock放在finally中，防止代码出错而不执行unlock导致程序卡死</strong></p>
<h2 id="4-Java中的多线程通信（综合以上内容的综合样例）"><a href="#4-Java中的多线程通信（综合以上内容的综合样例）" class="headerlink" title="4.Java中的多线程通信（综合以上内容的综合样例）"></a>4.Java中的多线程通信（综合以上内容的综合样例）</h2><big>常用的模型：生产者与消费者模型</big>

<p><strong>object中提供的等待唤醒方法如下</strong><br>|方法名称|说明|<br>|—-|—-|<br>|void wait()|当前线程等待并且释放所占锁，直到另外一个线程调用notify()或者notifyaAll|<br>|void notify()|唤醒正在等待的单个线程|<br>|void notufyAll()|唤醒正在等待的所有线程|</p>
<blockquote>
<p><strong>上述方法应该使用当前同步锁对象调用</strong><br><strong>注意：一定是先唤醒别人在等待，相当于自己叫醒别人再晕过去，否则相当于自己先晕过去没法叫人。</strong></p>
</blockquote>
<p>实例代码如下<br><strong>账户类：</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Account</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> String cardId;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">double</span> money;   <span class="comment">//余额</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Account</span><span class="params">(String cardId, <span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 小红 小明：取钱</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">DrawMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName(); <span class="comment">//取钱人</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.money &gt;= money) &#123;</span><br><span class="line">                <span class="comment">// 钱够，可以取钱</span></span><br><span class="line">                <span class="built_in">this</span>.money -= money;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;取钱成功，取出&quot;</span> + money + <span class="string">&quot;元！余额是：&quot;</span> + <span class="built_in">this</span>.money);</span><br><span class="line">                <span class="comment">// 没钱了</span></span><br><span class="line">                <span class="comment">// 钱不够</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();   <span class="comment">//唤醒其他所有的线程</span></span><br><span class="line">                <span class="built_in">this</span>.wait();    <span class="comment">//锁对象，让当前线程进入等待</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 钱不够，不可取</span></span><br><span class="line">                <span class="comment">// 唤醒别人存钱，等待自己取钱</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();   <span class="comment">//唤醒其他所有的线程</span></span><br><span class="line">                <span class="built_in">this</span>.wait();    <span class="comment">//锁对象，让当前线程进入等待</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 亲爹 干爹 岳父：取钱</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> money</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title function_">depositMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="type">String</span> <span class="variable">name</span> <span class="operator">=</span> Thread.currentThread().getName(); <span class="comment">//存钱人</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">this</span>.money == <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//没钱了，存钱</span></span><br><span class="line">                <span class="built_in">this</span>.money += money;</span><br><span class="line">                System.out.println(name + <span class="string">&quot;存钱&quot;</span> + money + <span class="string">&quot;元成功，余额为&quot;</span> + <span class="built_in">this</span>.money + <span class="string">&quot;元！&quot;</span>);</span><br><span class="line">                <span class="comment">// 存完钱了</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();   <span class="comment">//唤醒其他所有的线程</span></span><br><span class="line">                <span class="built_in">this</span>.wait();    <span class="comment">//锁对象，让当前线程进入等待</span></span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">// 有钱了，不用存钱</span></span><br><span class="line">                <span class="built_in">this</span>.notifyAll();   <span class="comment">//唤醒其他所有的线程</span></span><br><span class="line">                <span class="built_in">this</span>.wait();    <span class="comment">//锁对象，让当前线程进入等待</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getCardId</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setCardId</span><span class="params">(String cardId)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.cardId = cardId;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">getMoney</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> money;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMoney</span><span class="params">(<span class="type">double</span> money)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.money = money;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>取钱线程类：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取钱的线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DrawThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Account acc;    <span class="comment">//定义一个账户对象，便于对账户对象进行操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DrawThread</span><span class="params">(Account acc, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不断的存取前</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            acc.DrawMoney(<span class="number">100000</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">3</span> * <span class="number">1000</span>);     <span class="comment">//每隔三秒取一次钱</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>存钱线程类：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 取钱的线程类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DepositThread</span> <span class="keyword">extends</span> <span class="title class_">Thread</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Account acc;    <span class="comment">//定义一个账户对象，便于对账户对象进行操作</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">DepositThread</span><span class="params">(Account acc, String name)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name);</span><br><span class="line">        <span class="built_in">this</span>.acc = acc;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//不断的存取前</span></span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            acc.depositMoney(<span class="number">100000</span>);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(<span class="number">2</span> * <span class="number">1000</span>);     <span class="comment">//每隔两秒存一次钱</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>主程序：</strong><br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ThreadDemo</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 三个父亲线程（生产者） 两个孩子线程（消费者） 模拟存取钱通信思想（一存 一取）</span></span><br><span class="line">        <span class="comment">// 1.创建账户对象，代表五个人共同操作的账户</span></span><br><span class="line">        <span class="type">Account</span> <span class="variable">acc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Account</span>(<span class="string">&quot;ICBC-999&quot;</span>, <span class="number">0</span>);   <span class="comment">//初始化零元</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.创建两个取钱线程 小明 小红</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小明&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DrawThread</span>(acc, <span class="string">&quot;小红&quot;</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 3.创建三个存钱线程 亲爹 干爹 岳父</span></span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DepositThread</span>(acc, <span class="string">&quot;亲爹&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DepositThread</span>(acc, <span class="string">&quot;干爹&quot;</span>).start();</span><br><span class="line">        <span class="keyword">new</span> <span class="title class_">DepositThread</span>(acc, <span class="string">&quot;岳父&quot;</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果</p>
<p><img src="https://wang-nine.cn/images/JavaSE01-03%E7%BA%BF%E7%A8%8B%E9%80%9A%E4%BF%A1%E6%A0%B7%E4%BE%8B.png" alt="JavaSE01-03线程通信样例"></p>
<h2 id="5-线程池的创建以及使用"><a href="#5-线程池的创建以及使用" class="headerlink" title="5.线程池的创建以及使用"></a>5.线程池的创建以及使用</h2><p><strong>线程池是一个可以复用线程的技术。解决了每次都为新请求创建线程，导致开销较大的问题</strong><br>JDK5.0起提供了代表线程池的接口：ExecutorService<br>得到线程池对象的两种办法：<br>一、使用ExecutorService的实现类ThreadPoolExecutor自己创建一个线程池对象。<br>二、使用Executors（线程池的工具类）调用方法放回不同特点的线程池对象。</p>
<h3 id="①-线程池的API简介"><a href="#①-线程池的API简介" class="headerlink" title="① 线程池的API简介"></a><small>① 线程池的API简介</small></h3><p>ThreadPoolExecutor构造器：<br>public ThreadPoolExecutor（int corePoolSize<br>                           int maximumPoolSize,<br>                           long keepAliveTIme,<br>                           TimeUnit unit,<br>                           BlockingQueue<Runnable> workQueue,<br>                           ThreadFactory threadFactory,<br>                           RejectedExecutionHandler handler)<br>参数一：指定线程池的线程数量（核心线程）：corePoolsize                                    ——-&gt; 不能小于0<br>参数二：指定线程池可支持的最大线程数：maximumPoolSize                                 ———&gt; 最大数量&gt;=核心线程数量<br>参数三：指定临时线程的最大存活时间：keepAliveTime                                            ———&gt; 不能小于0<br>参数四：存活时间的单位（秒，分，时，天）：unit                                                   ———&gt; 时间单位<br>参数五：指定任务队列：workQueue                                                                            ———&gt; 不能为null<br>参数六：指定用那个线程工厂创建线程：threadFactory                                             ———&gt; 不能为null<br>参数七：指定线程忙，任务慢的时候，新任务来了怎么办，即拒绝策略：handler  ———&gt; 不能为null</p>
<blockquote>
<p><strong>（重要！！！）注意两点：</strong><br><strong>临时线程什么时候创建：新任务提交时发现核心线程都在忙，任务队列满，还可以创建临时线程时才会创建。</strong><br><strong>什么时候开始拒绝任务：核心线程和临时线程都在忙，任务队列都满，新任务过来会拒绝。</strong></p>
</blockquote>
<p>ExecutorService的常用方法：<br>|方法名称|说明|<br>|—-|—-|<br>|void execute(Runable command)|执行任务，无返回值，一般用于执行Runnable任务|<br>|Future<T> submit(Callable<T> Task|执行任务，返回未来任务对象获取线程结果，一般用于执行Runnable任务|<br>|void shutdown()|等待任务执行完毕后关闭线程池|<br>|List<Runnable> shutdownNow()|立即关闭，停止正在执行的任务，返回队列中未执行的任务|</p>
<p>拒绝策略：</p>
<div class="table-container">
<table>
<thead>
<tr>
<th>策略</th>
<th>详解</th>
</tr>
</thead>
<tbody>
<tr>
<td>ThreadPoolExecutor.AbortPolicy</td>
<td>丢弃任务抛出RejectedExecutionException异常</td>
</tr>
<tr>
<td>ThreadPoolExecutor.DiscardPolicy</td>
<td>丢弃任务不抛出异常（不推荐）</td>
</tr>
<tr>
<td>ThreadPoolExecutor.DiscardOldestPolicy</td>
<td>抛弃等待最久的任务并把当前任务加入队列</td>
</tr>
<tr>
<td>ThreadPoolExecutor.CallerRunsPolicy</td>
<td>由主线程负责调用的run()方法绕过线程池直接执行，即来新任务主线程亲自服务</td>
</tr>
</tbody>
</table>
</div>
<h3 id="②-线程池处理Runnable任务"><a href="#②-线程池处理Runnable任务" class="headerlink" title="② 线程池处理Runnable任务"></a><small>② 线程池处理Runnable任务</small></h3><p>样例代码：<br>Runnable实现代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyRunnable</span> <span class="keyword">implements</span> <span class="title class_">Runnable</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;输出了：HelloWorld&quot;</span> + i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 睡眠线程，观察线程的执行情况</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">&quot;本任务与线程绑定了，进入休眠状态了~~~&quot;</span>);</span><br><span class="line">            Thread.sleep(<span class="number">1000000</span>);  <span class="comment">//让其睡眠时间久一点，便于观察线程池的复用情况</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程池创建代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threadPoolDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建线程池对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *     public ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line"><span class="comment">         *                               int maximumPoolSize,</span></span><br><span class="line"><span class="comment">         *                               long keepAliveTime,</span></span><br><span class="line"><span class="comment">         *                               TimeUnit unit,</span></span><br><span class="line"><span class="comment">         *                               BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="comment">         *                               ThreadFactory threadFactory,</span></span><br><span class="line"><span class="comment">         *                               RejectedExecutionHandler handler) &#123;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把任务给线程池处理</span></span><br><span class="line">        <span class="type">Runnable</span> <span class="variable">target</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MyRunnable</span>();</span><br><span class="line">        <span class="comment">//核心线程运行</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//不创建临时线程</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);       <span class="comment">//任务队列满了！！核心线程都忙！！</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//创建临时线程</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//拒绝策略触发</span></span><br><span class="line">        pool.execute(target);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//关闭线程池（开发一般不使用，线程池作用就是长久存活）</span></span><br><span class="line">        <span class="comment">//pool.shutdownNow();     //立即关闭，即使任务未完成也关闭</span></span><br><span class="line">        <span class="comment">//pool.shutdown();    //等待任务执行完毕再关闭</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>拒绝策略样例：<br><img src="https://wang-nine.cn/images/JavaSE01-04%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%8B%92%E7%BB%9D%E7%AD%96%E7%95%A5%E6%A0%B7%E4%BE%8B.png" alt="JavaSE01-04线程池拒绝策略样例"></p>
<p>线程池运行样例：<br><img src="https://wang-nine.cn/images/JavaSE01-05Runnable%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E6%A0%B7%E4%BE%8B.png" alt="JavaSE01-05Runnable线程池运行样例"></p>
<h3 id="③-线程池处理Callable任务"><a href="#③-线程池处理Callable任务" class="headerlink" title="③ 线程池处理Callable任务"></a><small>③ 线程池处理Callable任务</small></h3><p>样例代码（简单测试一下，Callable实现在上面写过，具体使用方式与Runnable一致）：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">threadPoolDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="comment">// 1.创建线程池对象</span></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         *     public ThreadPoolExecutor(int corePoolSize,</span></span><br><span class="line"><span class="comment">         *                               int maximumPoolSize,</span></span><br><span class="line"><span class="comment">         *                               long keepAliveTime,</span></span><br><span class="line"><span class="comment">         *                               TimeUnit unit,</span></span><br><span class="line"><span class="comment">         *                               BlockingQueue&lt;Runnable&gt; workQueue,</span></span><br><span class="line"><span class="comment">         *                               ThreadFactory threadFactory,</span></span><br><span class="line"><span class="comment">         *                               RejectedExecutionHandler handler) &#123;</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="type">ExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>(<span class="number">3</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">                TimeUnit.SECONDS, <span class="keyword">new</span> <span class="title class_">ArrayBlockingQueue</span>&lt;&gt;(<span class="number">5</span>), Executors.defaultThreadFactory(),</span><br><span class="line">                <span class="keyword">new</span> <span class="title class_">ThreadPoolExecutor</span>.AbortPolicy());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.把任务给线程池处理</span></span><br><span class="line">        Future&lt;String&gt; f1 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">100</span>));</span><br><span class="line">        Future&lt;String&gt; f2 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">200</span>));</span><br><span class="line">        Future&lt;String&gt; f3 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">300</span>));</span><br><span class="line">        Future&lt;String&gt; f4 = pool.submit(<span class="keyword">new</span> <span class="title class_">MyCallable</span>(<span class="number">400</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(f1.get());</span><br><span class="line">        System.out.println(f2.get());</span><br><span class="line">        System.out.println(f3.get());</span><br><span class="line">        System.out.println(f4.get());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>线程池运行样例：<br><img src="https://wang-nine.cn/images/JavaSE01-06Callable%E7%BA%BF%E7%A8%8B%E6%B1%A0%E8%BF%90%E8%A1%8C%E6%A0%B7%E4%BE%8B.png" alt="JavaSE01-06Callable线程池运行样例"></p>
<h3 id="④-（重要！）-Executors工具类实现线程池"><a href="#④-（重要！）-Executors工具类实现线程池" class="headerlink" title="④ （重要！） Executors工具类实现线程池"></a><small>④ （重要！） Executors工具类实现线程池</small></h3><p>Executors获得线程池的常用方法：<br>|方法名称|说明|<br>|:—|—-|<br>|public static ExecutorService newCachedThreadPool()|线程数随着任务增加而增加，若线程任务执行完毕且空闲一段时间会被回收|<br>|public static ExecutorService newFixedThreadPool()|创建固定数量的线程池。若某个线程因为异常而结束，那么线程池会补充一个新线程代替它|<br>|public static ExecutorService newSingleThreadExecutor()|创建只有一个线程对象的线程池对象，如果该线程因为异常而结束，那么线程池会补充一个新线程|<br>|public static ScheduledExecutorService newScheduledThreadPool(int PoolSize)|创建一个线程池，可以实现在给定的延迟后运行任务，或者定期执行任务|</p>
<blockquote>
<p><strong>注意：Executors的底层其实也是基于线程池的实现类ThreadPoolExecutor创建线程池对象</strong><br><strong>注意：大型并发环境使用Executors如果不注意可能会出现系统风险，例如阿里开发手册不建议使用Executors创建线程池对象，而是建            议使用ThreadPoolExecutor自己创建</strong></p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">方法名称</th>
<th>存在问题</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">public static ExecutorService newCachedThreadPool()</td>
<td>允许请求的任务队列长度为Integer.MAX_VALUE，可能出现OOM错误(OutOfMemoryError)</td>
</tr>
<tr>
<td style="text-align:left">public static ExecutorService newFixedThreadPool()</td>
<td>同上</td>
</tr>
<tr>
<td style="text-align:left">public static ExecutorService newSingleThreadExecutor()</td>
<td>创建的线程数量上限为Integer.MAX_VALUE，线程数随着任务1:1增长，可能出现OOM错误(OutOfMemoryError)</td>
</tr>
<tr>
<td style="text-align:left">public static ScheduledExecutorService newScheduledThreadPool(int PoolSize)</td>
<td>同上</td>
</tr>
</tbody>
</table>
</div>
<h2 id="6-补充知识"><a href="#6-补充知识" class="headerlink" title="6.补充知识"></a>6.补充知识</h2><h3 id="①-定时器"><a href="#①-定时器" class="headerlink" title="① 定时器"></a><small>① 定时器</small></h3><blockquote>
<p>定时器是一种控制任务延时调用，或者周期调用的技术<br><strong>作用：闹钟，定时邮件发送</strong></p>
</blockquote>
<big>**定时器的两种实现方式如下**</big>

<h4 id="Timer"><a href="#Timer" class="headerlink" title="Timer"></a>Timer</h4><div class="table-container">
<table>
<thead>
<tr>
<th>构造器</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public Timer()</td>
<td>创建Timer定时器对象</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public void schedule(TimerTask task, long delay, long period）</td>
<td>开启一个定时器，按照计划处理TimerTask任务，delay是延时，period是周期</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>注意：TimerTask是Runnable的实现类</strong></p>
<p><strong>存在的问题：</strong><br><strong>Timer是单线程，处理多个任务有序执行，存在演示与设置定时器的时间有出入</strong><br><strong>可能因为某个任务的异常使得Timer线程死掉，从而影响后续任务的执行</strong></p>
</blockquote>
<p>样例代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"><span class="keyword">import</span> java.util.Timer;</span><br><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerDemo1</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建Timer定时器</span></span><br><span class="line">        <span class="type">Timer</span> <span class="variable">timer</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Timer</span>();  <span class="comment">//本身就是一个单线程</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.调用方法，给定定时任务</span></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务A~~~&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">5000</span>); <span class="comment">//休眠5s</span></span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2000</span>); <span class="comment">//三秒后执行，每隔两秒执行一次</span></span><br><span class="line"></span><br><span class="line">        timer.schedule(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务B~~~&quot;</span> + <span class="keyword">new</span> <span class="title class_">Date</span>());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2000</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 注意，本来A应该7s一次（2s间隔 + 5s睡眠），B应该2s一次</span></span><br><span class="line">        <span class="comment">// 实际情况与上述不符合，只存在一个线程，</span></span><br><span class="line">        <span class="comment">// B任务受到了A任务的影响</span></span><br><span class="line">        <span class="comment">// 其次，如果中间某个线程异常，其余线程都死亡</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行样例如下:<br><img src="https://wang-nine.cn/images/JavaSE01-06Timer%E6%A0%B7%E4%BE%8B.png" alt="JavaSE01-06Timer样例"></p>
<h4 id="ScheduledExecutorService"><a href="#ScheduledExecutorService" class="headerlink" title="ScheduledExecutorService"></a>ScheduledExecutorService</h4><blockquote>
<p><strong>ScheduledExecutorService弥补了Timer的缺陷</strong></p>
</blockquote>
<div class="table-container">
<table>
<thead>
<tr>
<th>Executors的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public static ScheduledExecutorService newScheduledThreadPool(int PoolSize</td>
<td>得到线程池对象</td>
</tr>
</tbody>
</table>
</div>
<div class="table-container">
<table>
<thead>
<tr>
<th>ScheduledExecutorService的方法</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>public Scheduled&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit)</td>
<td>周期调度方法</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p><strong>优点：基于线程池，某个任务的执行情况不会影响其他任务的执行</strong></p>
</blockquote>
<p>样例代码如下：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.TimerTask;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ScheduledExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">TimerDemo2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 1.创建ScheduledExecutorService线程池对象</span></span><br><span class="line">        <span class="type">ScheduledExecutorService</span> <span class="variable">pool</span> <span class="operator">=</span> Executors.newScheduledThreadPool(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 2.开启定时任务</span></span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务A~~~&quot;</span>);</span><br><span class="line">                <span class="comment">//把该线程堵塞</span></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    Thread.sleep(<span class="number">100000</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">2</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务B~~~&quot;</span>);</span><br><span class="line">                System.out.println(<span class="number">10</span> / <span class="number">0</span>); <span class="comment">//使该线程异常</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        pool.scheduleAtFixedRate(<span class="keyword">new</span> <span class="title class_">TimerTask</span>() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">&quot;执行任务C~~~&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;, <span class="number">0</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行样例如下：<br><img src="https://wang-nine.cn/images/JavaSE01-07ScheduledExecutorService%E7%BA%BF%E7%A8%8B%E6%B1%A0%E6%A0%B7%E4%BE%8B.png" alt="JavaSE01-07ScheduledExecutorService线程池样例"></p>
<blockquote>
<p><strong>异常不会影响</strong><br><strong>也不受其他任务的影响</strong></p>
</blockquote>
<h3 id="②-并发与并行"><a href="#②-并发与并行" class="headerlink" title="② 并发与并行"></a><small>② 并发与并行</small></h3><blockquote>
<p><strong>并发与并行：</strong><br><strong>正在运行的程序（软件）就是一个独立的进程，线程是属于进程的，多个线程其实是并发与并行同时进行的。</strong></p>
<p><strong>并发的理解：</strong><br><strong>CPU同时处理线程的数量有限。</strong><br><strong>CPU会轮询为系统的每个线程服务，由于CPU切换的速度很快，给我们的感觉这些线程在同时执行，这就是并发。</strong></p>
<p><strong>并行的理解：</strong><br><strong>在同一个时刻上，同时有多个线程在被CPU处理并执行。</strong></p>
</blockquote>
<h3 id="③-（重点！！！）线程的生命周期"><a href="#③-（重点！！！）线程的生命周期" class="headerlink" title="③ （重点！！！）线程的生命周期"></a><small>③ （重点！！！）线程的生命周期</small></h3><blockquote>
<p><strong>线程的状态:</strong><br><strong>也就是线程从生到死的过程，以及中间经历的各种状态及状态转换。理解线程的状态有利于提升并发编程的理解能力。</strong></p>
<p><strong>Java线程的状态：</strong><br><strong>Java总共定义了6种状态</strong><br><strong>6种状态都定义在Thread类的内部枚举类中。</strong></p>
</blockquote>
<p><strong>线程6种状态的转换如下图</strong></p>
<p><img src="https://wang-nine.cn/images/JavaSE01-08%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%E4%B9%8B%E9%97%B4%E7%9A%84%E8%BD%AC%E6%8D%A2.png" alt="JavaSE01-08线程状态之间的转换"></p>
<blockquote>
<p><strong>注意以下几点：</strong><br><strong>sleep()是睡眠，过程中不会释放锁对象，醒来后直接进入可运行状态</strong><br><strong>wait()是等待，过程中会释放锁对象，但是时间到了或者被notity时会重新获得锁对象，进入可运行状态</strong></p>
</blockquote>
<big>**总结：**</big>

<div class="table-container">
<table>
<thead>
<tr>
<th>线程状态</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>NEW（新建）</strong></td>
<td><strong>线程刚被创建，但是并未启动。</strong></td>
</tr>
<tr>
<td><strong>Runnable（可运行）</strong></td>
<td><strong>线程已经调用了start()等待CPU调度</strong></td>
</tr>
<tr>
<td><strong>Blocked（锁阻塞）</strong></td>
<td><strong>线程在执行的时候未竞争到锁对象，则该线程进入Blocked状态</strong></td>
</tr>
<tr>
<td><strong>Waiting（无限等待）</strong></td>
<td><strong>一个线程进入Waiting状态，另一个线程调用notify或者notifyAll方法才能够唤醒</strong></td>
</tr>
<tr>
<td><strong>Time Waiting（计时等待）</strong></td>
<td><strong>同waiting状态，有几个方法有超时参数，调用他们将进入Timed waiting状态。带有超时参数的常用方法有Thread.sleep和Object.wait</strong></td>
</tr>
<tr>
<td><strong>Teminated（被终止）</strong></td>
<td><strong>因为run方法正常退出而死亡，或者因为没有捕获的异常终止了run方法而死亡。</strong></td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>JavaSE</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>/posts/0.html</url>
    <content><![CDATA[<h2 id="MySQL8-0-26-Linux版安装"><a href="#MySQL8-0-26-Linux版安装" class="headerlink" title="MySQL8.0.26-Linux版安装"></a>MySQL8.0.26-Linux版安装</h2><h3 id="1-准备一台Linux服务器"><a href="#1-准备一台Linux服务器" class="headerlink" title="1. 准备一台Linux服务器"></a>1. 准备一台Linux服务器</h3><p>云服务器或者虚拟机都可以; </p>
<p>Linux的版本为 CentOS7;</p>
<h3 id="2-下载Linux版MySQL安装包"><a href="#2-下载Linux版MySQL安装包" class="headerlink" title="2. 下载Linux版MySQL安装包"></a>2. 下载Linux版MySQL安装包</h3><p><a href="https://downloads.mysql.com/archives/community/">https://downloads.mysql.com/archives/community/</a></p>
<h3 id="3-上传MySQL安装包"><a href="#3-上传MySQL安装包" class="headerlink" title="3. 上传MySQL安装包"></a>3. 上传MySQL安装包</h3><h3 id="4-创建目录-并解压"><a href="#4-创建目录-并解压" class="headerlink" title="4. 创建目录,并解压"></a>4. 创建目录,并解压</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir mysql</span><br><span class="line"></span><br><span class="line">tar -xvf mysql-8.0.26-1.el7.x86_64.rpm-bundle.tar -C mysql</span><br></pre></td></tr></table></figure>
<h3 id="5-安装mysql的安装包"><a href="#5-安装mysql的安装包" class="headerlink" title="5. 安装mysql的安装包"></a>5. 安装mysql的安装包</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd mysql</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-common-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-plugins-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-8.0.26-1.el7.x86_64.rpm </span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-libs-compat-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">yum install openssl-devel</span><br><span class="line"></span><br><span class="line">rpm -ivh  mysql-community-devel-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh mysql-community-client-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br><span class="line">rpm -ivh  mysql-community-server-8.0.26-1.el7.x86_64.rpm</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h3 id="6-启动MySQL服务"><a href="#6-启动MySQL服务" class="headerlink" title="6. 启动MySQL服务"></a>6. 启动MySQL服务</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl start mysqld</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl restart mysqld</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">systemctl stop mysqld</span><br></pre></td></tr></table></figure>
<h3 id="7-查询自动生成的root用户密码"><a href="#7-查询自动生成的root用户密码" class="headerlink" title="7. 查询自动生成的root用户密码"></a>7. 查询自动生成的root用户密码</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grep &#x27;temporary password&#x27; /var/log/mysqld.log</span><br></pre></td></tr></table></figure>
<p>命令行执行指令 :</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>然后输入上述查询到的自动生成的密码, 完成登录 .</p>
<h3 id="8-修改root用户密码"><a href="#8-修改root用户密码" class="headerlink" title="8. 修改root用户密码"></a>8. 修改root用户密码</h3><p>登录到MySQL之后，需要将自动生成的不便记忆的密码修改了，修改成自己熟悉的便于记忆的密码。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ALTER  USER  &#x27;root&#x27;@&#x27;localhost&#x27;  IDENTIFIED BY &#x27;1234&#x27;;</span><br></pre></td></tr></table></figure>
<p>执行上述的SQL会报错，原因是因为设置的密码太简单，密码复杂度不够。我们可以设置密码的复杂度为简单类型，密码长度为4。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set global validate_password.policy = 0;</span><br><span class="line">set global validate_password.length = 4;</span><br></pre></td></tr></table></figure>
<p>降低密码的校验规则之后，再次执行上述修改密码的指令。</p>
<h3 id="9-创建用户"><a href="#9-创建用户" class="headerlink" title="9. 创建用户"></a>9. 创建用户</h3><p>默认的root用户只能当前节点localhost访问，是无法远程访问的，我们还需要创建一个root账户，用户远程访问</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">create user &#x27;root&#x27;@&#x27;%&#x27; IDENTIFIED WITH mysql_native_password BY &#x27;1234&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="10-并给root用户分配权限"><a href="#10-并给root用户分配权限" class="headerlink" title="10. 并给root用户分配权限"></a>10. 并给root用户分配权限</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">grant all on *.* to &#x27;root&#x27;@&#x27;%&#x27;;</span><br></pre></td></tr></table></figure>
<h3 id="11-重新连接MySQL"><a href="#11-重新连接MySQL" class="headerlink" title="11. 重新连接MySQL"></a>11. 重新连接MySQL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mysql -u root -p</span><br></pre></td></tr></table></figure>
<p>然后输入密码</p>
<h3 id="12-通过DataGrip远程连接MySQL"><a href="#12-通过DataGrip远程连接MySQL" class="headerlink" title="12. 通过DataGrip远程连接MySQL"></a>12. 通过DataGrip远程连接MySQL</h3>]]></content>
  </entry>
  <entry>
    <title>MySQL01-事务</title>
    <url>/posts/10401.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的事务的四大特性以及事务的隔离级别。<br><span id="more"></span></p>
<h3 id="事务的简介"><a href="#事务的简介" class="headerlink" title="事务的简介"></a>事务的简介</h3><blockquote>
<p><strong>事务</strong>是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p>
<p>默认MySQL的事务是自动提交的，也就是说，当执行一条DML语句，MySQL会立即隐式的提交事务。</p>
</blockquote>
<h3 id="事务的操作"><a href="#事务的操作" class="headerlink" title="事务的操作"></a>事务的操作</h3><h4 id="提交事务的方式"><a href="#提交事务的方式" class="headerlink" title="提交事务的方式"></a>提交事务的方式</h4><h5 id="1-方式一"><a href="#1-方式一" class="headerlink" title="1.方式一"></a>1.方式一</h5><h6 id="①-查看-设置事务的提交方式"><a href="#①-查看-设置事务的提交方式" class="headerlink" title="① 查看/设置事务的提交方式"></a>① 查看/设置事务的提交方式</h6><blockquote>
<p>SELECT @@autocommit;<br>SET @@autocommit = 0;    —1是自动 0是手动</p>
<h6 id="②-提交事务"><a href="#②-提交事务" class="headerlink" title="② 提交事务"></a>② 提交事务</h6><p>COMMIT;    —提交事务</p>
<h6 id="③-回滚事务"><a href="#③-回滚事务" class="headerlink" title="③ 回滚事务"></a>③ 回滚事务</h6><p>ROLLBACK;    —回滚事务</p>
</blockquote>
<h5 id="2-方式二（手动开启并且提交）"><a href="#2-方式二（手动开启并且提交）" class="headerlink" title="2.方式二（手动开启并且提交）"></a>2.方式二（手动开启并且提交）</h5><h6 id="①-开启事务"><a href="#①-开启事务" class="headerlink" title="① 开启事务"></a>① 开启事务</h6><blockquote>
<p>START TRANSACTION / BEGIN;</p>
<h6 id="②-提交事务-1"><a href="#②-提交事务-1" class="headerlink" title="② 提交事务"></a>② 提交事务</h6><p>COMMIT；</p>
<h6 id="③-回滚事务-1"><a href="#③-回滚事务-1" class="headerlink" title="③ 回滚事务"></a>③ 回滚事务</h6><p>ROLLBACK;</p>
</blockquote>
<h3 id="事务的四大特性（ACID）"><a href="#事务的四大特性（ACID）" class="headerlink" title="事务的四大特性（ACID）"></a>事务的四大特性（ACID）</h3><blockquote>
<h4 id="原子性（Atomicity-∶事务是不可分割的最小操作单元，要么全部成功，要么全部失败。"><a href="#原子性（Atomicity-∶事务是不可分割的最小操作单元，要么全部成功，要么全部失败。" class="headerlink" title="原子性（Atomicity)∶事务是不可分割的最小操作单元，要么全部成功，要么全部失败。"></a><font size=3>原子性（<strong>A</strong>tomicity)∶事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</font></h4><h4 id="一致性（Consistency-事务完成时，必须使所有的数据都保持一致状态。"><a href="#一致性（Consistency-事务完成时，必须使所有的数据都保持一致状态。" class="headerlink" title="一致性（Consistency) :事务完成时，必须使所有的数据都保持一致状态。"></a><font size=3>一致性（Consistency) :事务完成时，必须使所有的数据都保持一致状态。</font></h4><h4 id="隔离性（lsolation-数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。"><a href="#隔离性（lsolation-数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。" class="headerlink" title="隔离性（lsolation):数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。"></a><font size=3>隔离性（<strong>l</strong>solation):数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</font></h4><h4 id="持久性（Durability-事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。"><a href="#持久性（Durability-事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。" class="headerlink" title="持久性（Durability) :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。"></a><font size=3>持久性（Durability) :事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</font></h4></blockquote>
<h3 id="并发事务的问题"><a href="#并发事务的问题" class="headerlink" title="并发事务的问题"></a>并发事务的问题</h3><div class="table-container">
<table>
<thead>
<tr>
<th>问题</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>脏读</td>
<td>一个事务读到另外一个事务还没有提交的数据。</td>
</tr>
<tr>
<td>不可重复读</td>
<td>一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读。</td>
</tr>
<tr>
<td>幻读</td>
<td>一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已存在，好像出现了’幻影”。</td>
</tr>
</tbody>
</table>
</div>
<h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">隔离级别</th>
<th style="text-align:center">脏读</th>
<th style="text-align:center">不可重复读</th>
<th style="text-align:center">幻读</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">Read Uncommitted</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Read Committed</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Repeatable Read（默认）</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">√</td>
</tr>
<tr>
<td style="text-align:center">Serializable</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
<td style="text-align:center">×</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL03-索引01-结构</title>
    <url>/posts/10403.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的索引的结构。<br><span id="more"></span></p>
<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>索引（index）是帮助MySQL<strong>高效获取数据</strong>的数据结构（有序）。在数据之外，数据库系统还维护着满足特定查找算法的数据结构，这些数据结构以某种方式引用（指向）数据，这样就可以在这些数据结构上实现高级查找算法，这种数据结构就是索引。</p>
<h3 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">优势</th>
<th style="text-align:left">劣势</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">提高数据检索的效率，降低数据库的IO成本</td>
<td style="text-align:left">索引列也会占用空间</td>
</tr>
<tr>
<td style="text-align:left">通过索引列对数据进行排序，降低数据排序的成本，降低CPU的消耗。</td>
<td style="text-align:left">索引大大提高了查询效率，同时却也降低更新表的速度，如对表进行INSERT、UPDATE、DELETE时,效率降低。</td>
</tr>
</tbody>
</table>
</div>
<p>但是：</p>
<blockquote>
<p><strong>目前磁盘很便宜，无所谓占用空间</strong></p>
<p><strong>目前业务查询 SELECT 频次很高，INSERT、UPDATE、DELETE等操作频次较少</strong></p>
<p><strong>综上，使用索引是非常有必要的</strong></p>
</blockquote>
<h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><h4 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h4><div class="table-container">
<table>
<thead>
<tr>
<th>索引结构</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>B+Tree索引</td>
<td>最常见的索引类型，大部分引擎都支持B+树索引</td>
</tr>
<tr>
<td>Hash索引</td>
<td>底层数据结构是用哈希表实现的，只有精确匹配索引列的查询才有效不支持范围查询</td>
</tr>
<tr>
<td>R-tree（空间索引）</td>
<td>空间索引是MylSAM引擎的一个特殊索引类型，主要用于地理空间数据类型，使用较少</td>
</tr>
<tr>
<td>Full-text（全文索引）</td>
<td>是一种通过建立倒排索引,快速匹配文档的方式。类似于Lucene，Solr，ES</td>
</tr>
</tbody>
</table>
</div>
<h4 id="引擎对于索引的支持情况"><a href="#引擎对于索引的支持情况" class="headerlink" title="引擎对于索引的支持情况"></a>引擎对于索引的支持情况</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">索引</th>
<th style="text-align:center">InnoDB</th>
<th style="text-align:center">MyISAM</th>
<th style="text-align:center">Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">B+tree索引</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">Hash索引</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">R-tree索引</td>
<td style="text-align:center">不支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
<tr>
<td style="text-align:center">Full-text</td>
<td style="text-align:center">5.6版本之后支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">不支持</td>
</tr>
</tbody>
</table>
</div>
<p>具体结构可以点击以下链接进入页面进行模拟操作：</p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/Algorithms.html">点击此处链接进行模拟数据结构</a></p>
<p><a href="https://www.cs.usfca.edu/~galles/visualization/BPlusTree.html">点击此处链接进行模拟B+树结构</a></p>
<p>具体数据结构在《数据结构》课中都有详细描述。</p>
<h4 id="B树结构样例如下："><a href="#B树结构样例如下：" class="headerlink" title="B树结构样例如下："></a>B树结构样例如下：</h4><p><img src="https://wang-nine.cn/images/MySQL03-01-01B%E6%A0%91.png" alt="MySQL03-01-01B树"></p>
<h4 id="B-树结构样例如下："><a href="#B-树结构样例如下：" class="headerlink" title="B+树结构样例如下："></a>B+树结构样例如下：</h4><p><img src="http://wang-nine.cn/images/MySQL03-01-02B+%E6%A0%91.png" alt="MySQL03-01-02B+树"></p>
<p><strong>B树与B+树的区别：</strong></p>
<blockquote>
<p>1.所有的数据都会出现在叶子节点</p>
<p>2.叶子节点形成了一个单向链表</p>
<p>3.MySQL索引数据结构对经典的B+Tree进行了优化。在原B+Tree的基础上，增加一个指向相邻叶子节点的链表指针，就形成了带有顺序指针的B+Tree，提高区间访问的性能。即MySQL将单向链表优化为双向链表。</p>
</blockquote>
<h4 id="Hash索引"><a href="#Hash索引" class="headerlink" title="Hash索引"></a>Hash索引</h4><p>Hash通过hash算法将键值对映射到指定位置，出现碰撞（hash冲突）可以通过链表解决。</p>
<blockquote>
<p>Hash索引特点<br>1.Hash索引只能用于对等比较(=，in)，不支持范围查询(between，&gt;，&lt;，….<br>2.无法利用索引完成排序操作<br>3.查询效率高，通常只需要一次检索就可以了，效率通常要高于B+tree索引</p>
</blockquote>
<p>在MySQL中，支持hash索引的是Memory引擎，而InnoDB中具有<strong>自适应hash功能</strong>，hash索引是存储引擎根据B+Tree索引在指定条件下自动构建的。</p>
<h4 id="为什么InnoDB存储引擎选择使用B-tree索引结构"><a href="#为什么InnoDB存储引擎选择使用B-tree索引结构" class="headerlink" title="为什么InnoDB存储引擎选择使用B+tree索引结构?"></a>为什么InnoDB存储引擎选择使用B+tree索引结构?</h4><blockquote>
<p>1.相对于二叉树，层级更少，搜索效率高;<br>2.对于B-tree，无论是叶子节点还是非叶子节点，都会保存数据，这样导致一页中存储的键值减少，指针跟着减少，要同样保存大量    数据，只能增加树的高度，导致性能降低;<br>3.相对Hash索引，B+tree支持范围匹配及排序操作;</p>
</blockquote>
<h3 id="索引分类"><a href="#索引分类" class="headerlink" title="索引分类"></a>索引分类</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">分类</th>
<th style="text-align:center">含义</th>
<th style="text-align:center">特点</th>
<th style="text-align:center">关键字</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">主键索引</td>
<td style="text-align:center">针对表中主键创建的索引</td>
<td style="text-align:center">默认自动创建，只能有一个</td>
<td style="text-align:center">PRIMARY</td>
</tr>
<tr>
<td style="text-align:center">唯一索引</td>
<td style="text-align:center">避免数据列重复</td>
<td style="text-align:center">可以多个</td>
<td style="text-align:center">UNIQUE</td>
</tr>
<tr>
<td style="text-align:center">常规索引</td>
<td style="text-align:center">快速查询</td>
<td style="text-align:center">可以多个</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">全文索引</td>
<td style="text-align:center">查找文本关键词，并非比较索引值</td>
<td style="text-align:center">可以多个</td>
<td style="text-align:center">FULLTEXT</td>
</tr>
</tbody>
</table>
</div>
<h3 id="InnoDB索引分类"><a href="#InnoDB索引分类" class="headerlink" title="InnoDB索引分类"></a>InnoDB索引分类</h3><div class="table-container">
<table>
<thead>
<tr>
<th>分类</th>
<th>含义</th>
<th>特点</th>
</tr>
</thead>
<tbody>
<tr>
<td>聚集索引(Clustered Index)</td>
<td>数据与索引放在一起，叶子节点保存了一行的数据</td>
<td>必须存在，且只有一个</td>
</tr>
<tr>
<td>二级索引(Secondary Index)</td>
<td>数据与索引分开存储，叶子节点存储对应主键</td>
<td>可以多个</td>
</tr>
</tbody>
</table>
</div>
<blockquote>
<p>聚集索引选取规则：<br>1.如果存在主键，主键索引就是聚集索引。<br>2.如果不存在主键，将使用第一含唯一（UNIQUE）索引作为聚集索引。<br>3.如果表没有主键，或没有合适的唯一索引，则InnoDB会自动生成一个rowid作为隐藏的聚集索引。</p>
</blockquote>
<p><strong>回表查询：</strong></p>
<p><strong>在二级索引中查询到主键，在聚集索引中根据主键查询到想要的数据</strong></p>
<blockquote>
<p>InnoDB主键索引的B+树高度为多高呢？</p>
<p>假设:<br>一行数据大小为1k，一页中可以存储16行这样的数据。InnoDB的指针占用6个字节的空间，主键即使为bigint，占用字节数为8。<br>高度为2:<br>n <em> 8 + (n + 1) </em> 6 = 16 <em> 1024，算出n约为1170<br>1171 </em> 16=18736<br>高度为3:<br>1171 <em> 1171 </em> 16 = 21939856</p>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL02-存储引擎</title>
    <url>/posts/10402.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的引擎之间的区别和选择。<br><span id="more"></span></p>
<h3 id="MySQL体系结构"><a href="#MySQL体系结构" class="headerlink" title="MySQL体系结构"></a>MySQL体系结构</h3><p><img src="https://wang-nine.cn/images/MySQL02-01%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84.png" alt="MySQL02-01体系结构"></p>
<h4 id="连接层"><a href="#连接层" class="headerlink" title="连接层"></a>连接层</h4><blockquote>
<p>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</p>
</blockquote>
<h4 id="服务层"><a href="#服务层" class="headerlink" title="服务层"></a>服务层</h4><blockquote>
<p>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</p>
</blockquote>
<h4 id="引擎层"><a href="#引擎层" class="headerlink" title="引擎层"></a>引擎层</h4><blockquote>
<p>存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</p>
</blockquote>
<h4 id="存储层"><a href="#存储层" class="headerlink" title="存储层"></a>存储层</h4><blockquote>
<p>主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</p>
</blockquote>
<h3 id="存储引擎简介"><a href="#存储引擎简介" class="headerlink" title="存储引擎简介"></a>存储引擎简介</h3><p>建表语句中使用 ENGINE = 引擎名 可以指定使用何种引擎<br>查看当前数据库支持的引擎： SHOW ENGINES；</p>
<h3 id="存储引擎的特点"><a href="#存储引擎的特点" class="headerlink" title="存储引擎的特点"></a>存储引擎的特点</h3><h4 id="InnoDB"><a href="#InnoDB" class="headerlink" title="InnoDB"></a>InnoDB</h4><p>简介<br>InnoDB是一种兼顾高可靠性和高性能的通用存储引擎，在MySQL 5.5之后，InnoDB是默认的MySQL存储引擎。</p>
<p>特点（事务，外键，行级锁）<br>DML操作遵循ACID模型,支持<strong>事务</strong><br>支持<strong>外键</strong>FOREIGN KEY约束，保证数据的完整性和正确性<br><strong>行级锁</strong>，提高并发访问性能</p>
<p>文件<br>xxx.ibd: xxx代表的是表名，innoDB引擎的每张表都会对应这样一个表空间文件，存储该表的表结构(frm、gdi) 、数据和索引。参数: innodb_file_per_table</p>
<p><img src="https://wang-nine.cn/iamges/MySQL02-02InnoDB.png" alt="MySQL02-02InnoDB"></p>
<h4 id="MyISAM"><a href="#MyISAM" class="headerlink" title="MyISAM"></a>MyISAM</h4><p>简介<br>MylSAM是MySQL早期的默认存储引擎。</p>
<p>特点<br>不支持事务<br>不支持外键支持表锁<br>不支持行锁访问速度快</p>
<p>文件<br>xxx.sdi:存储表结构信息<br>xxx.MYD:存储数据<br>xxx.MYI:存储索引</p>
<h4 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h4><p>介绍<br>Memory引擎的表数据时存储在内存中的，由于受到硬件问题、或断电问题的影响，只能将这些表作为临时表或缓存使用。</p>
<p>特点<br>内存存放<br>hash索引（默认)</p>
<p>文件<br>xxx.sdi:存储表结构信息</p>
<p>比较：（来自黑马程序员，侵删）</p>
<div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">特点</th>
<th style="text-align:center">InnoDB</th>
<th style="text-align:center">MyISAM</th>
<th style="text-align:center">Memory</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">存储限制</td>
<td style="text-align:center">64TB</td>
<td style="text-align:center">有</td>
<td style="text-align:center">有</td>
</tr>
<tr>
<td style="text-align:center">事务安全</td>
<td style="text-align:center"><strong>支持</strong></td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">锁机制</td>
<td style="text-align:center"><strong>行锁</strong></td>
<td style="text-align:center">表锁</td>
<td style="text-align:center">表锁</td>
</tr>
<tr>
<td style="text-align:center">B+Tree索引</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">Hash索引</td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
<td style="text-align:center">支持</td>
</tr>
<tr>
<td style="text-align:center">全文索引</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">支持</td>
<td style="text-align:center">-</td>
</tr>
<tr>
<td style="text-align:center">空间使用</td>
<td style="text-align:center">高</td>
<td style="text-align:center">低</td>
<td style="text-align:center">N/A</td>
</tr>
<tr>
<td style="text-align:center">内存使用</td>
<td style="text-align:center">高</td>
<td style="text-align:center">低</td>
<td style="text-align:center">中等</td>
</tr>
<tr>
<td style="text-align:center">批量插入速度</td>
<td style="text-align:center">低</td>
<td style="text-align:center">高</td>
<td style="text-align:center">高</td>
</tr>
<tr>
<td style="text-align:center">支持外键</td>
<td style="text-align:center"><strong>支持</strong></td>
<td style="text-align:center">-</td>
<td style="text-align:center">-</td>
</tr>
</tbody>
</table>
</div>
<h3 id="存储引擎的选择（总结自黑马程序员MySQL课程，侵删）"><a href="#存储引擎的选择（总结自黑马程序员MySQL课程，侵删）" class="headerlink" title="存储引擎的选择（总结自黑马程序员MySQL课程，侵删）"></a>存储引擎的选择（总结自黑马程序员MySQL课程，侵删）</h3><p>在选择存储引擎时，应该根据应用系统的特点选择合适的存储引擎。对于复杂的应用系统，还可以根据实际情况选择多种存储引擎进行组合。</p>
<p>InnoDB:是Mysql的默认存储引擎，支持事务、外键。如果应用对事务的完整性有比较高的要求，在并发条件下要求数据的一致性，数据操怍除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</p>
<p>MyISAM:如果应用是以读操作和插入操作为主，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。（被MongoDB取代）</p>
<p>MEMORY:将所有数据保存在内存中，访问速度快，通常用于临时表及缓存。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。（被Redis取代）</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL03-索引02-性能分析</title>
    <url>/posts/10404.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的索引的性能分析。<br><span id="more"></span></p>
<h3 id="索引创建的语法"><a href="#索引创建的语法" class="headerlink" title="索引创建的语法"></a>索引创建的语法</h3><h4 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h4><p>CREATE [UNIQUE|FULLTEXT] INDEX index_name ON table_name ( index_col_name … ) ;</p>
<h4 id="查看索引"><a href="#查看索引" class="headerlink" title="查看索引"></a>查看索引</h4><p>SHOW INDEX FROM table_name ;</p>
<h4 id="删除索引"><a href="#删除索引" class="headerlink" title="删除索引"></a>删除索引</h4><p>DROP INDEX index_name ON table_name ;</p>
<h3 id="性能分析"><a href="#性能分析" class="headerlink" title="性能分析"></a>性能分析</h3><h4 id="SQL执行频次"><a href="#SQL执行频次" class="headerlink" title="SQL执行频次"></a>SQL执行频次</h4><p>MySQL客户端连接成功后，通过show [session] global status 命令可以提供服务器状态信息。通过如下指令，可以查看当前数据库的INSERT、UPDATE、DELETE、SELECT的访问频次:<br>SHOW GLOBAL STATUS LIKE ‘Com<strong>__</strong>‘；<br><strong>注：Com后面六个下划线即为INSERT、UPDATE、DELETE、SELECTINSERT、UPDATE、DELETE、SELECT等单词的长度。</strong></p>
<h4 id="慢查询日志"><a href="#慢查询日志" class="headerlink" title="慢查询日志"></a>慢查询日志</h4><p>慢查询日志记录了所有执行时间超过指定参数 (long_query_time，单位:秒，默认10秒) 的所有SQL语句的日志。</p>
<p>MySQL的慢查询日志默认没有开启，需要在MySQL的配置文件 (/etc/my.cnf) 中配置如下信息:</p>
<blockquote>
<p>#开启MySQL慢日志查询开关<br>slow_query_log=1<br>#设置慢日志的时间为2秒，SQL语句执行时间超过2秒，就会视为慢查询，记录慢查询日志<br>long_query_time=2</p>
</blockquote>
<p>配置完毕之后，通过以下指令重新启动MySQL服务器进行测试，查看慢日志文件中记录的信息/var/lib/mysql/localhost-slow.log</p>
<h4 id="profile详情"><a href="#profile详情" class="headerlink" title="profile详情"></a>profile详情</h4><p>show profiles能够在做SQL优化时帮助我们了解时间的具体耗费。通过have_profiling参数，能够看到当前MySQL是否支持profile操作</p>
<blockquote>
<p>SELECT @@have_profiling;</p>
</blockquote>
<p>默认profiling是关闭的，可以通过set语句在session/global级别开启profiling</p>
<blockquote>
<p>SET profiling = 1;</p>
</blockquote>
<h4 id="重要！！！-explain执行计划"><a href="#重要！！！-explain执行计划" class="headerlink" title="(重要！！！)explain执行计划"></a>(重要！！！)explain执行计划</h4><p>EXPLAIN 或者 DESC 命令获取MySQL如何执行SELECT语句的信息，包括在SELECT语句执行过程中表如何连接和连接的顺序。</p>
<p>语法：</p>
<blockquote>
<h1 id="直接在select语句之前加上关键字explain-desc"><a href="#直接在select语句之前加上关键字explain-desc" class="headerlink" title="直接在select语句之前加上关键字explain / desc"></a>直接在select语句之前加上关键字explain / desc</h1><p>EXPLAIN SELECT 字段列表 FROM 表名 WHERE 条件;</p>
</blockquote>
<p>explain执行计划中包含的信息如下：</p>
<ul>
<li>id:  查询序列号</li>
<li>select_type: 查询类型</li>
<li>table: 表名或者别名</li>
<li>partitions: 匹配的分区</li>
<li>type: 访问类型</li>
<li>possible_keys: 可能用到的索引</li>
<li>key: 实际用到的索引</li>
<li>key_len: 索引长度</li>
<li>ref: 与索引比较的列</li>
<li>rows: 估算的行数</li>
<li>filtered: 按表条件筛选的行百分比</li>
<li>Extra: 额外信息</li>
</ul>
<h5 id="一、id列"><a href="#一、id列" class="headerlink" title="一、id列"></a>一、id列</h5><p>select查询的序列号(一组数字)，表示查询中执行select子句或者操作表的顺序。<br>id列分为三种情况：</p>
<ol>
<li>如果id相同，那么执行顺序从上到下</li>
<li>如果id不同，如果是子查询，id的序号会递增，id值越大优先级越高，越先被执行</li>
<li>id相同和不同的，同时存在，同时满足以上两种规则即可。</li>
</ol>
<h5 id="二、select-type列"><a href="#二、select-type列" class="headerlink" title="二、select_type列"></a>二、select_type列</h5><p>复制代码主要用来分辨查询的类型，是普通查询还是联合查询还是子查询</p>
<ol>
<li>sample: 简单的查询，不包含子查询和union</li>
<li>primary: 查询中若包含任何复杂的子查询，最外层查询则被标记为Primary</li>
<li>union: 在union，union all和子查询中的第二个和随后的select被标记为union</li>
<li>dependent union: 在包含UNION或者UNION ALL的大查询中，如果各个小查询都依赖于外层查询的话，那除了最左边的那个小查询之外，其余的小查询的select_type的值就是DEPENDENT UNION。</li>
<li>union result: 从union表获取结果的select。</li>
<li>subquery: 在select或者where列表中包含子查询（不在from子句中）</li>
<li>dependent subquery: 子查询中的第一个select（不在from子句中），而且取决于外面的查询。</li>
<li>derived: 在FROM列表中包含的子查询被标记为DERIVED，也叫做派生类</li>
<li>UNCACHEABLE SUBQUERY：一个子查询的结果不能被缓存，必须重新评估外链接的第一行对于外层的主表，子查询不可被物化，每次都需要计算（耗时操作）</li>
<li>uncacheable union: 表示union的查询结果不能被缓存：没找到具体的sql语句验证</li>
</ol>
<h5 id="三、table列"><a href="#三、table列" class="headerlink" title="三、table列"></a>三、table列</h5><p>对应行正在访问哪一个表，表名或者别名，可能是临时表或者union合并结果集.</p>
<ol>
<li>如果是具体的表名，则表明从实际的物理表中获取数据，当然也可以是表的别名.</li>
<li>表名是derivedN的形式，表示使用了id为N的查询产生的衍生表.</li>
<li>当有union result的时候，表名是union n1,n2等的形式，n1,n2表示参与union的id.</li>
</ol>
<h5 id="四，type列"><a href="#四，type列" class="headerlink" title="四，type列"></a>四，type列</h5><p>type是访问类型，访问类型表示以何种方式去访问我们的数据，<br>访问类型很多，效率从最好到最坏是：<br><strong>NULL &gt; system &gt; const &gt; eq_ref &gt; ref &gt; fulltext &gt; ref_or_null &gt; index_merge &gt; unique_subquery &gt; index_subquery &gt; range &gt; index &gt; ALL</strong></p>
<ol>
<li>all: 全表扫描，需要扫描整张表，从头到尾找到需要的数据行。一般情况下出现这样的sql语句而且数据量比较大的话那么就需要进行优化。</li>
<li>index：全索引扫描这个比all的效率要好，主要有两种情况，一种是当前的查询时覆盖索引，即我们需要的数据在索引中就可以索取，或者是使用了索引进行排序，这样就避免数据的重排序</li>
<li>range：表示利用索引查询的时候限制了范围，在指定范围内进行查询，这样避免了index的全索引扫描，适用的操作符：=, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, BETWEEN, LIKE, or IN() </li>
<li>index_subquery：利用索引来关联子查询，不再扫描全表但是大多数情况下使用SELECT子查询时，MySQL查询优化器会自动将子查询优化为联表查询，因此 type 不会显示为 index_subquery,而是ref</li>
<li>unique_subquery: 该连接类型类似于index_subquery,使用的是唯一索引。大多数情况下使用SELECT子查询时，MySQL查询优化器会自动将子查询优化为联表查询，因此 type 不会显示为 index_subquery,而是eq_ref</li>
<li>index_merge：在查询过程中需要多个索引组合使用.</li>
<li>ref_or_null：对于某个字段即需要关联条件，也需要null值的情况下，查询优化器会选择这种访问方式.</li>
<li>ref：使用了非唯一性索引进行数据的查找</li>
<li>eq_ref ：当进行等值联表查询使用主键索引或者唯一性非空索引进行数据查找(实际上唯一索引等值查询type不是eq_ref而是const)</li>
<li>const：最多只能匹配到一条数据，通常使用主键或唯一索引进行等值条件查询</li>
<li>system：表只有一行记录（等于系统表），这是const类型的特例，平时不会出现,不需要进行磁盘io</li>
<li>NULL：直接显示，例如 SELECT ‘A’ ，一般业务不可能优化为NULL</li>
</ol>
<h5 id="五、possible-keys列"><a href="#五、possible-keys列" class="headerlink" title="五、possible_keys列"></a>五、possible_keys列</h5><p>显示可能应用在这张表中的索引，一个或多个，查询涉及到的字段上若存在索引，则该索引将被列出，但不一定被查询实际使用。</p>
<h5 id="六、key列"><a href="#六、key列" class="headerlink" title="六、key列"></a>六、key列</h5><p>实际使用的索引，如果为null，则没有使用索引，查询中若使用了覆盖索引，则该索引和查询的select字段重叠。</p>
<h5 id="七、key-len列"><a href="#七、key-len列" class="headerlink" title="七、key_len列"></a>七、key_len列</h5><p>表示索引中使用的字节数，可以通过key_len计算查询中使用的索引长度，在不损失精度的情况下长度越短越好。<br>索引越大占用存储空间越大，这样io的次数和量就会增加，影响执行效率</p>
<h5 id="八、ref列"><a href="#八、ref列" class="headerlink" title="八、ref列"></a>八、ref列</h5><p>显示之前的表在key列记录的索引中查找值所用的列或者常量</p>
<h5 id="九、rows列"><a href="#九、rows列" class="headerlink" title="九、rows列"></a>九、rows列</h5><p>根据表的统计信息及索引使用情况，大致估算出找出所需记录需要读取的行数，此参数很重要，直接反应的sql找了多少数据，在完成目的的情况下越少越好。</p>
<h5 id="十、filtered列"><a href="#十、filtered列" class="headerlink" title="十、filtered列"></a>十、filtered列</h5><p>针对表中符合某个条件(where子句或者联接条件)的记录数的百分比所做的一个悲观估算。</p>
<h5 id="十一、extra列"><a href="#十一、extra列" class="headerlink" title="十一、extra列"></a>十一、extra列</h5><p>包含额外的信息。</p>
<ol>
<li>using filesort: 说明mysql无法利用索引进行排序，只能利用排序算法进行排序，会消耗额外的位置</li>
<li>using temporary: 建立临时表来保存中间结果，查询完成之后把临时表删除</li>
<li>using index: 这个表示当前的查询是覆盖索引的，直接从索引中读取数据，而不用访问数据表。如果同时出现using where 表名索引被用来执行索引键值的查找，如果没有，表面索引被用来读取数据，而不是真的查找</li>
<li>using where: 使用where进行条件过滤</li>
<li>using join buffer: 使用连接缓存</li>
<li>impossible where：where语句的结果总是false</li>
</ol>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL03-索引03-使用规则</title>
    <url>/posts/10405.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的索引的使用规则和设计原则。<br><span id="more"></span></p>
<h3 id="使用规则"><a href="#使用规则" class="headerlink" title="使用规则"></a>使用规则</h3><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><h5 id="最左前缀法则"><a href="#最左前缀法则" class="headerlink" title="最左前缀法则"></a>最左前缀法则</h5><blockquote>
<p>如果索引了多列(联合索引)，要遵守最左前缀法则。最左前缀法则指的是查询从索引的最左列开始，并且不跳过索引中的列。如果跳跃某一列，索引将部分失效(后面的字段索引失效)。</p>
</blockquote>
<h5 id="范围查询"><a href="#范围查询" class="headerlink" title="范围查询"></a>范围查询</h5><blockquote>
<p>联合索引中，出现范围查询(&gt;,&lt;)，范围查询右侧的列索引失效</p>
</blockquote>
<h4 id="索引失效"><a href="#索引失效" class="headerlink" title="索引失效"></a>索引失效</h4><h5 id="索引列运算"><a href="#索引列运算" class="headerlink" title="索引列运算"></a>索引列运算</h5><blockquote>
<p>不要在索引列上进行运算操作,索引将失效。</p>
</blockquote>
<h5 id="字符串不加引号"><a href="#字符串不加引号" class="headerlink" title="字符串不加引号"></a>字符串不加引号</h5><blockquote>
<p>字符串类型字段使用时，不加引号，索引将失效。会在内部自动进行隐式类型转换。</p>
</blockquote>
<h5 id="模糊查询"><a href="#模糊查询" class="headerlink" title="模糊查询"></a>模糊查询</h5><blockquote>
<p>如果仅仅是尾部模糊匹配，索引不会失效。如果是头部模糊匹配，索引失效。</p>
</blockquote>
<h5 id="or连接的条件"><a href="#or连接的条件" class="headerlink" title="or连接的条件"></a>or连接的条件</h5><blockquote>
<p>用or分割开的条件，如果or前的条件中的列有索引，而后面的列中没有索引，那么涉及的索引都不会被用到。</p>
<p>解决办法：针对另一个数据列也建立索引即可</p>
</blockquote>
<h5 id="数据分布影响"><a href="#数据分布影响" class="headerlink" title="数据分布影响"></a>数据分布影响</h5><blockquote>
<p>如果MysQL评估使用索引比全表更慢，则不使用索引。</p>
</blockquote>
<h4 id="SQL提示"><a href="#SQL提示" class="headerlink" title="SQL提示"></a>SQL提示</h4><h5 id="SQL提示-1"><a href="#SQL提示-1" class="headerlink" title="SQL提示"></a>SQL提示</h5><blockquote>
<p>SQL提示，是优化数据库的一个重要手段，简单来说，就是在SQL语句中加入一些人为的提示来达到优化操作的目的。</p>
<p>放在where条件前，use/ignore/force index(索引名)</p>
<p>use index:   建议使用索引，数据库可以选择不使用</p>
<p>ignore index:   忽略某个索引</p>
<p>force index:   强制使用某个索引</p>
</blockquote>
<h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><h5 id="覆盖索引-1"><a href="#覆盖索引-1" class="headerlink" title="覆盖索引"></a>覆盖索引</h5><blockquote>
<p>尽量使用覆盖索引（查询使用了索引，并且需要返回的列，在该索引中已经全部能够找到)，减少select *。</p>
<p>尽量避免回表查询</p>
<p>extra中：<br>using index condition :查找使用了索引,但是需要回表查询数据<br>using where; using index:查找使用了索引，但是需要的数据都在索引列中能找到，所以不需要回表查询数据</p>
</blockquote>
<h4 id="前缀索引"><a href="#前缀索引" class="headerlink" title="前缀索引"></a>前缀索引</h4><h5 id="前缀索引-1"><a href="#前缀索引-1" class="headerlink" title="前缀索引"></a>前缀索引</h5><blockquote>
<p>当字段类型为字符串(varchar, text等）时，有时候需要索引很长的字符串，这会让索引变得很大，查询时，浪费大量的磁盘IO，影响查询效率。此时可以只将字符串的一部分前缀，建立索引，这样可以大大节约索引空间，从而提高索引效率。</p>
<p>语法：<br>create index idx_xxx on table_name(column(n)) ;        - - n为前缀长度</p>
<p>前缀长度的选择：<br>可以根据索引的选择性来决定，选择性是指不重复的索引值（基数）和数据表的记录总数的比值，索引选择性越高则查询效率越高，<br>唯一索引的选择性是1，这是最好的索引选择性，性能也是最好的。<br>可以使用聚合函数查询选择性<br>select count(distinct substring(xxx,1,5))/ count(*) from table ;  - - 即长度为5的选择性</p>
</blockquote>
<h4 id="单列-联合索引"><a href="#单列-联合索引" class="headerlink" title="单列/联合索引"></a>单列/联合索引</h4><h5 id="单列索引与联合索引"><a href="#单列索引与联合索引" class="headerlink" title="单列索引与联合索引"></a>单列索引与联合索引</h5><blockquote>
<p>单列索引:即一个索引只包含单个列。</p>
<p>联合索引:即一个索引包含了多个列。</p>
<p>在业务场景中，如果存在多个查询条件，考虑针对于查询字段建立索引时，建议建立联合索引，而非单列索引。</p>
<p>多条件联合查询时，MySQL优化器会评估哪个字段的索引效率更高，会选择该索引完成本次查询。</p>
</blockquote>
<h3 id="索引设计原则（总结自黑马程序员，侵删）"><a href="#索引设计原则（总结自黑马程序员，侵删）" class="headerlink" title="索引设计原则（总结自黑马程序员，侵删）"></a>索引设计原则（总结自黑马程序员，侵删）</h3><h5 id="索引设计原则"><a href="#索引设计原则" class="headerlink" title="索引设计原则"></a>索引设计原则</h5><blockquote>
<ol>
<li>针对于数据量较大，且查询比较频繁的表建立索引。</li>
<li>针对于常作为查询条件（where)、排序(order by)、分组(group by)操作的字段建立索引。</li>
<li>尽量选择区分度高的列作为索引，尽量建立唯一索引，区分度越高，使用索引的效率越高。</li>
<li>如果是字符串类型的字段，字段的长度较长，可以针对于字段的特点，建立前缀索引。</li>
<li>尽量使用联合索引，减少单列索引，查询时，联合索引很多时候可以覆盖索引，节省存储空间，避免回表，提高查询效率。</li>
<li>要控制索引的数量，索引并不是多多益善，索引越多，维护索引结构的代价也就越大，会影响增删改的效率。</li>
<li>如果索引列不能存储NULL值，请在创建表时使用NOT NULL约束它。当优化器知道每列是否包含NULL值时，它可以更好地确定哪个索引最有效地用于查询。</li>
</ol>
</blockquote>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL04-SQL优化</title>
    <url>/posts/10406.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的SQL语句的优化。<br><span id="more"></span></p>
<h3 id="MySQL语句优化"><a href="#MySQL语句优化" class="headerlink" title="MySQL语句优化"></a>MySQL语句优化</h3><h4 id="插入数据优化"><a href="#插入数据优化" class="headerlink" title="插入数据优化"></a>插入数据优化</h4><h5 id="批量插入"><a href="#批量插入" class="headerlink" title="批量插入"></a>批量插入</h5><blockquote>
<h1 id="客户端连接服务端时，加上参数"><a href="#客户端连接服务端时，加上参数" class="headerlink" title="客户端连接服务端时，加上参数"></a>客户端连接服务端时，加上参数</h1><p>—local-infilemysql —local-infile -u root -p</p>
<h1 id="设置全局参数local-infile为，开启从本地加载文件导入数据的开关"><a href="#设置全局参数local-infile为，开启从本地加载文件导入数据的开关" class="headerlink" title="设置全局参数local_infile为，开启从本地加载文件导入数据的开关"></a>设置全局参数local_infile为，开启从本地加载文件导入数据的开关</h1><p>set global local_infile = 1;</p>
<h1 id="执行load指令将准备好的数据，加载到表结构中"><a href="#执行load指令将准备好的数据，加载到表结构中" class="headerlink" title="执行load指令将准备好的数据，加载到表结构中"></a>执行load指令将准备好的数据，加载到表结构中</h1><p>load data local infile ‘/root/sql1.log’ into table ‘table’ fields terminated by ‘,’ lines terminated by ‘\n’;</p>
</blockquote>
<h5 id="手动提交事务"><a href="#手动提交事务" class="headerlink" title="手动提交事务"></a>手动提交事务</h5><h5 id="主键顺序插入"><a href="#主键顺序插入" class="headerlink" title="主键顺序插入"></a>主键顺序插入</h5><p>主键顺序插入性能高于乱序插入</p>
<h4 id="主键优化"><a href="#主键优化" class="headerlink" title="主键优化"></a>主键优化</h4><h5 id="数据组织方式"><a href="#数据组织方式" class="headerlink" title="数据组织方式"></a>数据组织方式</h5><blockquote>
<p>在InnoDB存储引擎中，表数据都是根据主键顺序组织存放的，这种存储方式的表称为索引组织表(index organized table IOT)。</p>
</blockquote>
<h5 id="页分裂"><a href="#页分裂" class="headerlink" title="页分裂"></a>页分裂</h5><blockquote>
<p>页可以为空，也可以填充一半，也可以填充100%。每个页包含了2-N行数据(如果一行数据多大，会行溢出)，根据主键排列。<br>主键乱序插入</p>
</blockquote>
<h5 id="页合并"><a href="#页合并" class="headerlink" title="页合并"></a>页合并</h5><blockquote>
<p>当删除一行记录时，实际上记录并没有被物理删除，只是记录被标记（flaged)为删除并且它的空间变得允许被其他记录声明使用。<br>当页中删除的记录达到MERGE_THRESHOLD(默认为页的50%)，InnoDB会开始寻找最靠近的页（前或后）看看是否可以将两个页合并以优化空间使用。</p>
</blockquote>
<h5 id="主键设计原则"><a href="#主键设计原则" class="headerlink" title="主键设计原则"></a>主键设计原则</h5><blockquote>
<ol>
<li>满足业务需求的情况下，尽量降低主键的长度。</li>
<li>插入数据时，尽量选择顺序插入，选择使用AUTO_INCREMENT自增主键。</li>
<li>尽量不要使用UUID做主键或者是其他自然主键，如身份证号。</li>
</ol>
</blockquote>
<h4 id="order-by-语句优化"><a href="#order-by-语句优化" class="headerlink" title="order by 语句优化"></a>order by 语句优化</h4><h5 id="Using-flesort"><a href="#Using-flesort" class="headerlink" title="Using flesort"></a>Using flesort</h5><p>通过表的索引或全表扫描，读取满足条件的数据行，然后在排序缓冲区sort buffer中完成排序操作，所有不是通过索引直接返回排序结果的排序都叫FileSort排序。</p>
<h5 id="Using-index"><a href="#Using-index" class="headerlink" title="Using index"></a>Using index</h5><p>通过有序索引顺序扫描直接返回有序数据，这种情况即为using index，不需要额外排序，操作效率高。</p>
<h5 id="优化原则"><a href="#优化原则" class="headerlink" title="优化原则"></a>优化原则</h5><blockquote>
<ol>
<li>根据排序字段建立合适的索引，多字段排序时，也遵循最左前缀法则。</li>
<li>尽量使用覆盖索引。</li>
<li>多字段排序,一个升序一个降序，此时需要注意联合索引在创建时的规则(ASC/DESC)。</li>
<li>如果不可避免的出现filesort，大数据量排序时，可以适当增大排序缓冲区大小 sort_buffer_size(默认256k)。</li>
</ol>
</blockquote>
<h4 id="group-by-语句优化"><a href="#group-by-语句优化" class="headerlink" title="group by 语句优化"></a>group by 语句优化</h4><h5 id="优化原则-1"><a href="#优化原则-1" class="headerlink" title="优化原则"></a>优化原则</h5><blockquote>
<ol>
<li>在分组操作时，可以通过索引来提高效率。</li>
<li>分组操作时，索引的使用也是满足最左前缀法则的。</li>
</ol>
</blockquote>
<h4 id="limit-语句优化"><a href="#limit-语句优化" class="headerlink" title="limit 语句优化"></a>limit 语句优化</h4><p><strong>一个常见又非常头疼的问题就是limit 20000000,10，此时需要MySQL排序前2000010记录，仅仅返回2000000 - 2000010的记录，其他记录丢弃，查询排序的代价非常大。</strong></p>
<h5 id="优化原则-2"><a href="#优化原则-2" class="headerlink" title="优化原则"></a>优化原则</h5><p>一般分页查询时，通过创建覆盖索引能够比较好地提高性能，可以通过覆盖索引加子查询形式进行优化。</p>
<h4 id="count-语句优化"><a href="#count-语句优化" class="headerlink" title="count 语句优化"></a>count 语句优化</h4><p>MylSAM引擎把二个表的总行数存在了磁盘上，因此执行count(*)的时候会直接返回这个数，效率很高<br>InnoDB引擎就麻烦了，它执行count(*)的时候，需要把数据一行一行地从引擎里面读出来，然后累积计数</p>
<h5 id="优化原则：自己计数"><a href="#优化原则：自己计数" class="headerlink" title="优化原则：自己计数"></a>优化原则：自己计数</h5><blockquote>
<ol>
<li>count (主键)<br> InnoDB引擎会遍历整张表，把每一行的主键id值都取出来，返回给服务层。服务层拿到主键后，直接按行进行累加(主键不可能为null)</li>
<li>count (字段)<br> 没有not null约束: InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，服务层判断，不为null，计数累加。有not null约束: InnoDB引擎会遍历整张表把每一行的字段值都取出来，返回给服务层，直接按行进行累加。</li>
<li>count (1)<br> InnoDB引擎遍历整张表，但不取值。服务层对于返回的每一行，放一个数字“1”进去，直接按行进行累加。</li>
<li>count (*)<br> lnnoDB引擎并不会把全部字段取出来，而是专门做了优化，不取值，服务层直接按行进行累加。</li>
</ol>
</blockquote>
<p><strong>按照效率排序的话，count(字段):xcount(主键id)&lt; count(1) = count(<em>)，所以尽量使用count(</em>)。</strong></p>
<h4 id="update-语句优化-避免行级锁变为表级锁"><a href="#update-语句优化-避免行级锁变为表级锁" class="headerlink" title="update 语句优化(避免行级锁变为表级锁)"></a>update 语句优化(避免行级锁变为表级锁)</h4><h5 id="优化原则-3"><a href="#优化原则-3" class="headerlink" title="优化原则"></a>优化原则</h5><p>InnoDB的行锁是针对索引加的锁，不是针对记录加的锁,并且该索引不能失效，否则会从行锁升级为表锁。</p>
<h3 id="MySQL优化总结"><a href="#MySQL优化总结" class="headerlink" title="MySQL优化总结"></a>MySQL优化总结</h3><h5 id="插入数据"><a href="#插入数据" class="headerlink" title="插入数据"></a>插入数据</h5><p>insert:批量插入、手动控制事务、主键顺序插入<br>大批量插入: load data local infile</p>
<h5 id="主键优化-1"><a href="#主键优化-1" class="headerlink" title="主键优化"></a>主键优化</h5><p>主键长度尽量短、顺序插入<br>AUTO_INCREMENT  <del>UUID</del></p>
<h5 id="order-by优化"><a href="#order-by优化" class="headerlink" title="order by优化"></a>order by优化</h5><p>using index:直接通过索引返回数据，性能高<br>using filesort:需要将返回的结果在排序缓冲区排序</p>
<h5 id="group-by优化"><a href="#group-by优化" class="headerlink" title="group by优化"></a>group by优化</h5><p>索引，多字段分组满足最左前缀法则</p>
<h5 id="limit优化"><a href="#limit优化" class="headerlink" title="limit优化"></a>limit优化</h5><p>覆盖索引+子查询</p>
<h5 id="count优化"><a href="#count优化" class="headerlink" title="count优化"></a>count优化</h5><p>性能: count(字段) &lt; count(主键id) &lt; count(1) &lt; count(*)</p>
<h5 id="update优化"><a href="#update优化" class="headerlink" title="update优化"></a>update优化</h5><p>尽量根据主键/索引字段进行数据更新</p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL06-存储函数</title>
    <url>/posts/10408.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的存储函数。<br><span id="more"></span></p>
<h3 id="存储函数"><a href="#存储函数" class="headerlink" title="存储函数"></a>存储函数</h3><p>存储函数是有返回值的存储过程，存储函数的参数只能是IN类型的。</p>
<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE FUNCTION 存储函数名称([参数列表])</span><br><span class="line">RETURNS type [characteristic ...]</span><br><span class="line">BEGIN</span><br><span class="line">	--SQL语句</span><br><span class="line">	RETURN ...;</span><br><span class="line">END;</span><br><span class="line"></span><br><span class="line">characteristic说明:</span><br><span class="line"> + DETERMINISTIC:相同的输入参数总是产生相同的结果</span><br><span class="line"> + NO SQL:不包含SQL语句。</span><br><span class="line"> + READS SQL DATA:包含读取数据的语句，但不包含写入数据的语句。</span><br></pre></td></tr></table></figure>
<h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 存储函数</span><br><span class="line">-- 计算从1到n的累加</span><br><span class="line">create function fun1(n int)</span><br><span class="line">returns int deterministic </span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line"></span><br><span class="line">    while n &gt; 0 do</span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end while;</span><br><span class="line"></span><br><span class="line">    return total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">select fun1(100);</span><br></pre></td></tr></table></figure>
<p><strong>注意当未添加 deterministic 会产生如下bug：</strong></p>
<p><img src="https://wang-nine.cn/images/MySQL06-01%E6%9C%AA%E6%8C%87%E5%AE%9A%E5%8F%82%E6%95%B0%E6%80%A7%E8%B4%A8%E7%9A%84bug.png" alt="MySQL06-01未指定参数性质的bug"></p>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/MySQL06-02%E5%AD%98%E5%82%A8%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="MySQL06-02存储函数的运行结果"></p>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><p><strong>存储函数必须要有返回值，而且参数只能是输入类型的参数，其过程实现完全可以被存储过程所代替。</strong></p>
<p><strong>因此存储函数的使用较少，这里仅做了解。</strong></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL05-存储过程</title>
    <url>/posts/10407.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的存储过程。<br><span id="more"></span></p>
<h3 id="存储过程介绍"><a href="#存储过程介绍" class="headerlink" title="存储过程介绍"></a>存储过程介绍</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><ul>
<li>存储过程是事先经过编译并存储在数据库中的一段SQL语句的集合，调用存储过程可以简化应用开发人员的很多工作，减少数据在数据库和应用服务器之间的传输，对于提高数据处理的效率是有好处的。</li>
<li>存储过程思想上很简单，就是数据库SQL语言层面的代码封装与重用。</li>
</ul>
<h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul>
<li>封装，复用</li>
<li>可以接收参数，也可以返回数据</li>
<li>减少网络交互，效率提升</li>
</ul>
<h3 id="存储过程语法"><a href="#存储过程语法" class="headerlink" title="存储过程语法"></a>存储过程语法</h3><h4 id="创建"><a href="#创建" class="headerlink" title="创建"></a>创建</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名称([参数列表])</span><br><span class="line">BEGIN</span><br><span class="line">	...SQL语句</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<h4 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CALL 名称([参数]);</span><br></pre></td></tr></table></figure>
<h4 id="查看"><a href="#查看" class="headerlink" title="查看"></a>查看</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUINE_SQHEMA = &#x27;xxx&#x27;;  --查询指定数据库的存储过程及状态信息</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW CREATE PROCEDURE 存储过程名称; --查询某个存储过程的定义</span><br></pre></td></tr></table></figure>
<h4 id="删除"><a href="#删除" class="headerlink" title="删除"></a>删除</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DROP PROCEDURE [IF EXISTS] 存储过程名称;</span><br></pre></td></tr></table></figure>
<h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><p>注意：在命令行中，执行创建存储过程的SQL时，需要通过关键字 delimiter 指定SQL语句的结束符。</p>
<p>可以设置为两个$$符号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">delimiter $$</span><br></pre></td></tr></table></figure>
<h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="系统变量"><a href="#系统变量" class="headerlink" title="系统变量"></a>系统变量</h4><p>系统变量是MySQL服务器提供，不是用户定义的，属于服务器层面。分为全局变量（GLOBAL）、会话变量（SESSION）</p>
<h5 id="查看系统变量"><a href="#查看系统变量" class="headerlink" title="查看系统变量"></a>查看系统变量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW [SESSION|GLOBAL] VARIABLES; --查看所有系统变量</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SHOW [SESSION|GLOBAL] VARIABLES LIKE ...; --可以通过LIKE模糊匹配方式查找变量</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @@[SESSION|GLOBAL] 系统变量名; --查看指定变量的值</span><br></pre></td></tr></table></figure>
<h5 id="设置系统变量"><a href="#设置系统变量" class="headerlink" title="设置系统变量"></a>设置系统变量</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET [SESSION|GLOBAL] 系统变量名 = 值;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @@[SESSION|GLOBAL] 系统变量名 = 值;</span><br></pre></td></tr></table></figure>
<p><strong>注意:</strong></p>
<ul>
<li>如果没有指定SESSION/GLOBAL，默认是SESSION，会话变量。</li>
<li>mysql服务重新启动之后，所设置的全局参数会失效，要想不失效，可以在/etc/my.cnf 中配置。</li>
</ul>
<h4 id="用户定义变量"><a href="#用户定义变量" class="headerlink" title="用户定义变量"></a>用户定义变量</h4><p>用户定义变量是用户根据需要自己定义的变量，用户变量不用提前声明，在用的时候直接用“@变量名”使用就可以。其作用域为当前连接即当前会话。</p>
<h5 id="赋值"><a href="#赋值" class="headerlink" title="赋值"></a>赋值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET @var_name = expr [,@var_name = expr] ...;</span><br><span class="line">SET @var_name := expr [,@var_name := expr] ...;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @var_name := expr [, @var_name := expr]... ;</span><br><span class="line">SELECT 字段名 INTO @var_name FROM 表名;</span><br></pre></td></tr></table></figure>
<h5 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT @var_name;</span><br></pre></td></tr></table></figure>
<p><strong>注意：</strong></p>
<ul>
<li><strong>在MySQL中， = 既可以作为赋值，也可以作为比较，因此在赋值时建议使用 := </strong></li>
<li><strong>用户定义的变量无需对其进行声明或初始化，只不过获取到的值为NULL.</strong></li>
</ul>
<h4 id="局部变量"><a href="#局部变量" class="headerlink" title="局部变量"></a>局部变量</h4><p>局部变量是根据需要定义的在局部生效的变量，访问之前，需要DECLARE声明。可用作存储过程内的局部变量和输入参数，局部变量的范围是在其内声明的BEGIN….END块。</p>
<h5 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 变量名变量类型 [DEFAULT ...];</span><br></pre></td></tr></table></figure>
<h5 id="赋值-1"><a href="#赋值-1" class="headerlink" title="赋值"></a>赋值</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET 变量名 = 值;</span><br><span class="line">SET 变量名 := 值;</span><br><span class="line">SELECT 字段名 INTO 变量名 FROM 表名 ...;</span><br></pre></td></tr></table></figure>
<h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><h4 id="存储过程-if-判断"><a href="#存储过程-if-判断" class="headerlink" title="存储过程 - if 判断"></a>存储过程 - if 判断</h4><h5 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IF 条件1 THEN</span><br><span class="line">	...</span><br><span class="line">ELSE IF 条件2 THEN --可选</span><br><span class="line">	...</span><br><span class="line">ELSE --可选</span><br><span class="line">	...</span><br><span class="line">END IF;</span><br></pre></td></tr></table></figure>
<h5 id="无参数的存储过程样例"><a href="#无参数的存储过程样例" class="headerlink" title="无参数的存储过程样例"></a>无参数的存储过程样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 判定分数对应的分数等级。</span><br><span class="line">-- score &gt;= 85分，等级为优秀。</span><br><span class="line">-- score &gt;= 60分且score &lt; 85分，等级为及格。</span><br><span class="line">-- score &lt; 60分，等级为不及格。</span><br><span class="line">create procedure p1()</span><br><span class="line">begin</span><br><span class="line">    declare score int default 58;</span><br><span class="line">    declare result varchar(10);</span><br><span class="line">    if score &gt;= 85 then</span><br><span class="line">        set result := &#x27;优秀&#x27;;</span><br><span class="line">    elseif score &gt;= 60 then</span><br><span class="line">        set result := &#x27;及格&#x27;;</span><br><span class="line">    else</span><br><span class="line">        set result := &#x27;不及格&#x27;;</span><br><span class="line">    end if;</span><br><span class="line">    select result;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p1();</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/MySQL05-01%E6%97%A0%E5%8F%82%E6%95%B0if%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" alt="MySQL05-01无参数if存储过程"></p>
<h4 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h4><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">类型</th>
<th>含义</th>
<th style="text-align:center">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">IN</td>
<td>该类参数作为输入，也就是需要调用时传入值</td>
<td style="text-align:center">默认</td>
</tr>
<tr>
<td style="text-align:center">OUT</td>
<td>该类参数作为输出,也就是该参数可以作为返回值</td>
<td style="text-align:center">/</td>
</tr>
<tr>
<td style="text-align:center">INOUT</td>
<td>既可以作为输入参数,也可以作为输出参数</td>
<td style="text-align:center">/</td>
</tr>
</tbody>
</table>
</div>
<h5 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CREATE PROCEDURE 存储过程名称 ([IN / OUT / INOUT 参数名 参数类型])</span><br><span class="line">BEGIN</span><br><span class="line">	--SQL语句</span><br><span class="line">END;</span><br></pre></td></tr></table></figure>
<h5 id="有参数的存储过程样例"><a href="#有参数的存储过程样例" class="headerlink" title="有参数的存储过程样例"></a>有参数的存储过程样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据传入(in)参数score，判定当前分数对应的分数等级，并返回(out)。</span><br><span class="line">-- score &gt;= 85分，等级为优秀。</span><br><span class="line">-- score &gt;= 60分且score &lt; 85分，等级为及格。</span><br><span class="line">-- score &lt; 60分，等级为不及格。</span><br><span class="line">create procedure p1(in score int, out result varchar(10))</span><br><span class="line">begin</span><br><span class="line">    if score &gt;= 85 then</span><br><span class="line">        set result := &#x27;优秀&#x27;;</span><br><span class="line">    elseif score &gt;= 60 then</span><br><span class="line">        set result := &#x27;及格&#x27;;</span><br><span class="line">    else</span><br><span class="line">        set result := &#x27;不及格&#x27;;</span><br><span class="line">    end if;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p1(68, @result);</span><br><span class="line">select @result;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/MySQL05-02%E6%9C%89%E5%8F%82%E6%95%B0if%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" alt="MySQL05-02有参数if存储过程.png"></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 将传入的 200分制的分数,进行换算,换算成百分制，然后返阿分数---&gt; inout</span><br><span class="line">create procedure p2(inout score double)</span><br><span class="line">begin</span><br><span class="line">    set score := score * 0.5;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">set @score = 163;</span><br><span class="line">call p2(@score);</span><br><span class="line">select @score;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/MySQL05-03%E6%9C%89%E5%8F%82%E6%95%B0%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" alt="MySQL05-03有参数存储过程"></p>
<h4 id="存储过程-Case"><a href="#存储过程-Case" class="headerlink" title="存储过程 - Case"></a>存储过程 - Case</h4><h5 id="语法一"><a href="#语法一" class="headerlink" title="语法一"></a>语法一</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE case_value</span><br><span class="line">	WHEN when_value1 THEN statement_list1</span><br><span class="line">	[WHEN when_value2 THEN statement_Kist 2] ...</span><br><span class="line">	[ELSE statement_list]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>
<h5 id="语法二"><a href="#语法二" class="headerlink" title="语法二"></a>语法二</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CASE</span><br><span class="line">	WHEN search_condition1 THEN statement_list1</span><br><span class="line">	[WHEN search_condition2 THEN statement_list2] ...</span><br><span class="line">	[ELSE statemept tlist]</span><br><span class="line">END CASE;</span><br></pre></td></tr></table></figure>
<h5 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 根据传入的月份，判定月份所属的季节（要求采用case结构)。</span><br><span class="line">-- 1.1-3月份,为第一季度</span><br><span class="line">-- 2.4-6月份，为第二季度</span><br><span class="line">-- 3.7-9月份，为第三季度</span><br><span class="line">-- 4.10-12月份，为第四季度</span><br><span class="line">create procedure p3(in month int)</span><br><span class="line">begin</span><br><span class="line">    declare result varchar(10);</span><br><span class="line"></span><br><span class="line">    case</span><br><span class="line">        when month &gt;= 1 and month &lt;= 3</span><br><span class="line">            then set result := &#x27;第一季度&#x27;;</span><br><span class="line">        when month &gt;= 4 and month &lt;= 6</span><br><span class="line">            then set result := &#x27;第二季度&#x27;;</span><br><span class="line">        when month &gt;= 7 and month &lt;= 9</span><br><span class="line">            then set result := &#x27;第三季度&#x27;;</span><br><span class="line">        when month &gt;= 10 and month &lt;= 12</span><br><span class="line">            then set result := &#x27;第四季度&#x27;;</span><br><span class="line">        else</span><br><span class="line">            set result := &#x27;非法参数&#x27;;</span><br><span class="line">    end case;</span><br><span class="line">    select concat(&#x27;您输入的月份为&#x27;, month, &#x27;所属的季度为&#x27;, result);</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p3(4)</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/MySQL05-03case%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" alt="MySQL05-03case存储过程"></p>
<h4 id="存储过程循环-while"><a href="#存储过程循环-while" class="headerlink" title="存储过程循环 - while"></a>存储过程循环 - while</h4><p><strong>while循环是有条件的循环控制语句。满足条件后，再执行循环体中的SQL语句。</strong></p>
<h5 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先判定条件，如果条件为true，则执行逻辑，否则，不执行逻辑</span><br><span class="line">WHILE 条件 DO</span><br><span class="line">	SQL逻辑...</span><br><span class="line">END WHILE;</span><br></pre></td></tr></table></figure>
<h5 id="样例-1"><a href="#样例-1" class="headerlink" title="样例"></a>样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算从1紧加到的值，n为传入的参数值。</span><br><span class="line">-- 1. 定义局部变量，记录累加后的值</span><br><span class="line">-- 2. 每新环一次,就会n进行减1,如果n减到0，则退出循环</span><br><span class="line">create procedure p4(in n int)</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    while n &gt; 0 do</span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end while;</span><br><span class="line">    select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p4(10);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/MySQL05-04while%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" alt="MySQL05-04while存储过程.png"></p>
<h4 id="存储过程循环-repeat"><a href="#存储过程循环-repeat" class="headerlink" title="存储过程循环 - repeat"></a>存储过程循环 - repeat</h4><p><strong>repeat是有条件的循环控制语句，当满足条件的时候退出循环。</strong></p>
<h5 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#先执行一次逻辑，然后判定逻辑是否满足，如果满足，则退出。如果不满足，则继续下一次循环</span><br><span class="line">REPEAT</span><br><span class="line">	SQL逻辑 ...</span><br><span class="line">	UNTIL 条件</span><br><span class="line">END REPEAT;</span><br></pre></td></tr></table></figure>
<h5 id="样例-2"><a href="#样例-2" class="headerlink" title="样例"></a>样例</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算从1紧加到的值，n为传入的参数值。</span><br><span class="line">-- 1. 定义局部变量，记录累加后的值</span><br><span class="line">-- 2. 每新环一次,就会n进行减1,如果n减到0，则退出循环</span><br><span class="line">create procedure p5(in n int)</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    repeat</span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    until n &lt;= 0</span><br><span class="line">    end repeat;</span><br><span class="line">    select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p5(10);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/MySQL05-04while%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" alt="MySQL05-04while存储过程.png"></p>
<h4 id="存储过程循环-loop"><a href="#存储过程循环-loop" class="headerlink" title="存储过程循环 - loop"></a>存储过程循环 - loop</h4><p><strong>LOOP实现简单的循环，如果不在SQL逻辑中增加退出循环的条件，可以用其来实现简单的死循环。</strong></p>
<p><strong>LOOP可以配合一下两个语句使用</strong></p>
<ul>
<li><strong>LEAVE：配合循环使用，退出循环。</strong></li>
<li><strong>ITERATE：必须用在循环中，作用是跳过当前循环剩下的语句，直接进入下一次循环。</strong></li>
</ul>
<h5 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[begin_label:] LOOP</span><br><span class="line">	SQL逻辑 ...</span><br><span class="line">END LOOP [end_label];</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">LEAVE label; --退出指定标记的循环体</span><br><span class="line">ITERATE label; --直接进入下一次循环</span><br></pre></td></tr></table></figure>
<h5 id="样例1"><a href="#样例1" class="headerlink" title="样例1"></a>样例1</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算从1紧加到的值,n为传入的参数值。</span><br><span class="line">-- 1. 定义局部变量,记录累加后的值</span><br><span class="line">-- 2. 每新环一次,就会n进行减1,如果n减到0，则退出循环   ---&gt; leave xxx;</span><br><span class="line">create procedure p6(in n int)</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    sum : loop</span><br><span class="line">        if n &lt;= 0 then</span><br><span class="line">            leave sum;</span><br><span class="line">        end if;</span><br><span class="line"></span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end loop;</span><br><span class="line">    select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p6(10);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/MySQL05-04while%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" alt="MySQL05-04while存储过程.png"></p>
<h5 id="样例2"><a href="#样例2" class="headerlink" title="样例2"></a>样例2</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 计算从1到n之问的偶数累加的值，n为传入的参数值。</span><br><span class="line">-- 1．定义局部变量，记录累加之后的值;</span><br><span class="line">-- 2．每循环一次，就会对n进行-1，如果n减到0，则退出循环   ---&gt; leave xxx</span><br><span class="line">-- 3．如果当次累加的数据是奇数，则直接进入下一次循环   ---&gt; iterate xxx</span><br><span class="line">create procedure p7(in n int)</span><br><span class="line">begin</span><br><span class="line">    declare total int default 0;</span><br><span class="line">    sum : loop</span><br><span class="line">        if n &lt;= 0 then</span><br><span class="line">            leave sum;</span><br><span class="line">        end if;</span><br><span class="line"></span><br><span class="line">        if n % 2 = 1 then</span><br><span class="line">            set n := n - 1;</span><br><span class="line">            iterate sum;</span><br><span class="line">        end if;</span><br><span class="line"></span><br><span class="line">        set total := total + n;</span><br><span class="line">        set n := n - 1;</span><br><span class="line">    end loop;</span><br><span class="line">    select total;</span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p7(10);</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/MySQL05-05loop%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B.png" alt="MySQL05-05loop存储过程"></p>
<h4 id="游标-Cursor"><a href="#游标-Cursor" class="headerlink" title="游标 - Cursor"></a>游标 - Cursor</h4><p>游标（CURSOR）是用来存储查询结果集的数据类型，在存储过程和函数中可以使用游标对结果集进行循环的处理。</p>
<p>游标的使用包括游标的声明、OPEN、FETCH 和 CLOSE，其语法分别如下。</p>
<h5 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h5><h6 id="声明游标"><a href="#声明游标" class="headerlink" title="声明游标"></a>声明游标</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE 游标名称 CURSOR FOR 查询语句;</span><br></pre></td></tr></table></figure>
<h6 id="打开游标"><a href="#打开游标" class="headerlink" title="打开游标"></a>打开游标</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">OPEN 游标名称;</span><br></pre></td></tr></table></figure>
<h6 id="获取游标记录"><a href="#获取游标记录" class="headerlink" title="获取游标记录"></a>获取游标记录</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">FETCH 游标名称 INTO 变量[变量];</span><br></pre></td></tr></table></figure>
<h6 id="关闭游标"><a href="#关闭游标" class="headerlink" title="关闭游标"></a>关闭游标</h6><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLOSE 游标名称;</span><br></pre></td></tr></table></figure>
<h4 id="样例-3"><a href="#样例-3" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 游标</span><br><span class="line">-- 根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名(name)和专业（profession)，</span><br><span class="line">-- 并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中</span><br><span class="line"></span><br><span class="line">-- 逻辑</span><br><span class="line">-- 1. 声明游标，存储查询到的结果集</span><br><span class="line">-- 2. 准备：创建表结构</span><br><span class="line">-- 3. 开启游标</span><br><span class="line">-- 4， 获取游标中的记录</span><br><span class="line">-- 5. 将记录插入到新的表中</span><br><span class="line">-- 6. 关闭游标</span><br><span class="line">create procedure p8(in uage int)</span><br><span class="line">begin</span><br><span class="line">    declare uname varchar(100);</span><br><span class="line">    declare upro varchar(100);</span><br><span class="line">    declare u_cursor cursor for select name, profession from tb_user where age &lt;= uage;</span><br><span class="line"></span><br><span class="line">    drop table if exists tb_user_pro;</span><br><span class="line">    create table if not exists tb_user_pro(</span><br><span class="line">        id int primary key auto_increment,</span><br><span class="line">        name varchar(100),</span><br><span class="line">        profession varchar(100)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    open u_cursor;</span><br><span class="line"></span><br><span class="line">    while true do</span><br><span class="line">        fetch u_cursor into uname, upro;</span><br><span class="line">        insert into tb_user_pro values (null, uname, upro);</span><br><span class="line">    end while;</span><br><span class="line"></span><br><span class="line">    close u_cursor;</span><br><span class="line"></span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p8(30);</span><br></pre></td></tr></table></figure>
<p><strong>注意while的循环退出条件为true，即死循环，产生如下bug</strong></p>
<p><img src="https://wang-nine.cn/images/MySQL05-06cursor%E4%B8%AD%E7%9A%84bug.png" alt="MySQL05-06cursor中的bug"></p>
<p><strong>注意</strong></p>
<ul>
<li>普通变量的声明先与游标</li>
<li>循环中如何得知循环结束的条件？即游标什么时候遍历完？</li>
</ul>
<h4 id="条件处理程序"><a href="#条件处理程序" class="headerlink" title="条件处理程序"></a>条件处理程序</h4><p>条件处理程序（Handler）可以用来定义在流程控制结构执行过程中遇到问题时相应的处理步骤。</p>
<h5 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">DECLARE handler_action HANDLER FOR condition_value [,condition_value] ... statement;</span><br><span class="line"></span><br><span class="line">handler_action</span><br><span class="line">	cONTINUE:继续执行当前程序</span><br><span class="line">	EXIT:终止执行当前程序</span><br><span class="line">condition_value</span><br><span class="line">	SQLSTATE:sqlstate_value:状态码，如02000</span><br><span class="line">	SQLWARNING:所有以01开头的SQLSTATE代码的简写</span><br><span class="line">	NOT FOUND:所有以02开头的SQLSTATE代码的简写</span><br><span class="line">	SQLEXCEPTION:所有没有被SQLWARNING 或 NOT FOUND捕获的SQLSTATE代码的简写</span><br></pre></td></tr></table></figure>
<h5 id="样例-改进了循环退出判断条件"><a href="#样例-改进了循环退出判断条件" class="headerlink" title="样例(改进了循环退出判断条件)"></a>样例(改进了循环退出判断条件)</h5><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-- 游标</span><br><span class="line">-- 根据传入的参数uage，来查询用户表tb_user中，所有的用户年龄小于等于uage的用户姓名(name)和专业（profession)，</span><br><span class="line">-- 并将用户的姓名和专业插入到所创建的一张新表(id,name,profession)中</span><br><span class="line"></span><br><span class="line">-- 逻辑</span><br><span class="line">-- 1. 声明游标，存储查询到的结果集</span><br><span class="line">-- 2. 准备：创建表结构</span><br><span class="line">-- 3. 开启游标</span><br><span class="line">-- 4， 获取游标中的记录</span><br><span class="line">-- 5. 将记录插入到新的表中</span><br><span class="line">-- 6. 关闭游标</span><br><span class="line">create procedure p8(in uage int)</span><br><span class="line">begin</span><br><span class="line">    declare uname varchar(100);</span><br><span class="line">    declare upro varchar(100);</span><br><span class="line">    declare u_cursor cursor for select name, profession from tb_user where age &lt;= uage;</span><br><span class="line"></span><br><span class="line">    -- 声明条件处理程序，当状态码为 02000 时关闭游标</span><br><span class="line">    -- 也可以写为 declare exit handler for not found close u_cursor;</span><br><span class="line">    declare exit handler for sqlstate &#x27;02000&#x27; close u_cursor;</span><br><span class="line"></span><br><span class="line">    drop table if exists tb_user_pro;</span><br><span class="line">    create table if not exists tb_user_pro(</span><br><span class="line">        id int primary key auto_increment,</span><br><span class="line">        name varchar(100),</span><br><span class="line">        profession varchar(100)</span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    open u_cursor;</span><br><span class="line"></span><br><span class="line">    while true do</span><br><span class="line">        fetch u_cursor into uname, upro;</span><br><span class="line">        insert into tb_user_pro values (null, uname, upro);</span><br><span class="line">    end while;</span><br><span class="line"></span><br><span class="line">    close u_cursor;</span><br><span class="line"></span><br><span class="line">end;</span><br><span class="line"></span><br><span class="line">call p8(30);</span><br></pre></td></tr></table></figure>
<p>具体的详细的官方解释的状态码如下</p>
<p><a href="https://dev.mysql.com/doc/mysql-errors/8.0/en/server-error-reference.html">MySQL官网文档状态码解释</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL07-触发器</title>
    <url>/posts/10409.html</url>
    <content><![CDATA[<p>详细的描述了MySQL中的触发器。<br><span id="more"></span></p>
<h3 id="触发器简介"><a href="#触发器简介" class="headerlink" title="触发器简介"></a>触发器简介</h3>]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>MySQL总览</title>
    <url>/posts/10400.html</url>
    <content><![CDATA[<h3 id="MySQL01-事务"><a href="#MySQL01-事务" class="headerlink" title="MySQL01-事务"></a>MySQL01-事务</h3><p><a href="https://wang-nine.cn/posts/10401.html">MySQL01-事务</a></p>
<h3 id="MySQL02-存储引擎"><a href="#MySQL02-存储引擎" class="headerlink" title="MySQL02-存储引擎"></a>MySQL02-存储引擎</h3><p><a href="https://wang-nine.cn/posts/10402.html">MySQL02-存储引擎</a></p>
<h3 id="MySQL03-索引01-结构"><a href="#MySQL03-索引01-结构" class="headerlink" title="MySQL03-索引01-结构"></a>MySQL03-索引01-结构</h3><p><a href="https://wang-nine.cn/posts/10403.html">MySQL03-索引01-结构</a></p>
<h3 id="MySQL03-索引02-性能分析"><a href="#MySQL03-索引02-性能分析" class="headerlink" title="MySQL03-索引02-性能分析"></a>MySQL03-索引02-性能分析</h3><p><a href="https://wang-nine.cn/posts/10404.html">MySQL03-索引02-性能分析</a></p>
<h3 id="MySQL03-索引03-使用规则"><a href="#MySQL03-索引03-使用规则" class="headerlink" title="MySQL03-索引03-使用规则"></a>MySQL03-索引03-使用规则</h3><p><a href="https://wang-nine.cn/posts/10405.html">MySQL03-索引03-使用规则</a></p>
<h3 id="MySQL04-SQL优化"><a href="#MySQL04-SQL优化" class="headerlink" title="MySQL04-SQL优化"></a>MySQL04-SQL优化</h3><p><a href="https://wang-nine.cn/posts/10406.html">MySQL04-SQL优化</a></p>
<h3 id="MySQL05-存储过程"><a href="#MySQL05-存储过程" class="headerlink" title="MySQL05-存储过程"></a>MySQL05-存储过程</h3><p><a href="https://wang-nine.cn/posts/10407.html">MySQL05-存储过程</a></p>
<h3 id="MySQL06-存储函数"><a href="#MySQL06-存储函数" class="headerlink" title="MySQL06-存储函数"></a>MySQL06-存储函数</h3><p><a href="https://wang-nine.cn/posts/10408.html">MySQL06-存储函数</a></p>
<h3 id="MySQL07-触发器"><a href="#MySQL07-触发器" class="headerlink" title="MySQL07-触发器"></a>MySQL07-触发器</h3><p><a href="https://wang-nine.cn/posts/10409.html">MySQL07-触发器</a></p>
]]></content>
      <categories>
        <category>MySQL</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM01-Spring中的Bean</title>
    <url>/posts/10301.html</url>
    <content><![CDATA[<p> 简单的介绍了Spring中的架构以及IOC和DI。<br><span id="more"></span></p>
<h3 id="Spring-FrameWork架构"><a href="#Spring-FrameWork架构" class="headerlink" title="Spring FrameWork架构"></a>Spring FrameWork架构</h3><p><strong>Spring Framework是Spring生态圈中最基础的项目，是其他项目的根基</strong></p>
<p><strong>Spirng FrameWork的架构</strong></p>
<p><img src="https://wang-nine.cn/images/SSM01-01SpringFrameWork%E6%9E%B6%E6%9E%84.png" alt="SSM01-01SpringFrameWork架构"></p>
<h3 id="Spring核心概念"><a href="#Spring核心概念" class="headerlink" title="Spring核心概念"></a>Spring核心概念</h3><h4 id="IoC-Inversion-of-Control-控制反转"><a href="#IoC-Inversion-of-Control-控制反转" class="headerlink" title="IoC ( Inversion of Control )控制反转"></a><strong>IoC ( Inversion of Control )控制反转</strong></h4><blockquote>
<p>使用对象时，由主动new产生对象转换为由<strong>外部</strong>提供对象，此过程中对象创建控制权由程序转移到<strong>外部</strong>，此思想称为控制反转</p>
<p>Spring技术对IoC思想进行了实现Spring提供了一个容器，，称为IoC容器，用来充当IoC思想中的”<strong>外部</strong>“</p>
<p>IoC容器负责对象的创建、初始化等一系列工作，被创建或被管理的对象在IoC容器中统称为Bean</p>
</blockquote>
<h4 id="DI-Dependency-Injection-依赖注入"><a href="#DI-Dependency-Injection-依赖注入" class="headerlink" title="DI ( Dependency Injection)依赖注入"></a><strong>DI ( Dependency Injection)依赖注入</strong></h4><blockquote>
<p>在容器中建立bean与bean之间的依赖关系的整个过程，称为依赖注入</p>
</blockquote>
<h3 id="IoC入门案例"><a href="#IoC入门案例" class="headerlink" title="IoC入门案例"></a>IoC入门案例</h3><blockquote>
<p>思路分析：<br>1.管理什么? （Service与Dao）<br>2.如何将被管理的对象告知IoC容器?（配置）<br>3.被管理的对象交给IoC容器，如何获取到IoC容器?（接口）<br>4.IoC容器得到后，如何从容器中获取bean ?（接口方法）<br>5.使用Spring导入哪些坐标?（pom.xml）</p>
</blockquote>
<h4 id="非Spring环境下"><a href="#非Spring环境下" class="headerlink" title="非Spring环境下"></a>非Spring环境下</h4><p>案例代码如下：</p>
<p>Service层的代码：<br>接口：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"><span class="keyword">import</span> wang.dao.impl.DaoImpl;</span><br><span class="line"><span class="keyword">import</span> wang.service.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">Dao</span> <span class="variable">dao</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DaoImpl</span>();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service save() ...&quot;</span>);</span><br><span class="line">        dao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>DAO层的代码：<br>接口：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Dao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>实现：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoImpl</span> <span class="keyword">implements</span> <span class="title class_">Dao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao save() ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主函数代码：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wang.service.Service;</span><br><span class="line"><span class="keyword">import</span> wang.service.impl.ServiceImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ServiceImpl</span>();</span><br><span class="line">        service.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：<br><img src="https://wang-nine.cn/images/SSM01-02%E9%9D%9ESpring%E7%8E%AF%E5%A2%83%E6%A0%B7%E4%BE%8B.png" alt="SSM01-02非Spring环境样例"></p>
<h4 id="Spring环境下"><a href="#Spring环境下" class="headerlink" title="Spring环境下"></a>Spring环境下</h4><p>别忘记在pom.xml中引入spring-context<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>在resources中创建配置文件（名称：applicationContext.xml）：如图<br><img src="https://wang-nine.cn/images/SSM01-03%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6.png" alt="SSM01-03配置文件"></p>
<p>在配置文件中输入以下的代码<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--导入spring的坐标spring-context，对应版本是5.2.10.RELEASE--&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--配置bean--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--bean标签标示配置bean</span></span><br><span class="line"><span class="comment">    id属性标示给bean起名字</span></span><br><span class="line"><span class="comment">    class属性表示给bean定义类型--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.dao.impl.DaoImpl&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Service&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.service.impl.ServiceImpl&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>主函数代码<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> wang.service.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="comment">// 获取IoC容器</span></span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取Bean</span></span><br><span class="line">        <span class="type">Service</span> <span class="variable">service</span> <span class="operator">=</span> (Service) ctx.getBean(<span class="string">&quot;Service&quot;</span>);</span><br><span class="line">        service.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>此时运行样例与非Spring方式相同如下：<br><img src="https://wang-nine.cn/images/SSM01-04Spring%E7%8E%AF%E5%A2%83%E6%A0%B7%E4%BE%8B.png" alt="SSM01-04Spring环境样例"></p>
<p><strong>综上：可以分为四步</strong></p>
<blockquote>
<p><strong>1.导入Spring坐标</strong></p>
<p><strong>2.定义Spring管理的类（接口）</strong></p>
<p><strong>3.创建Spring配置文件进行配置</strong></p>
<p><strong>4.初始化IoC容器，从容器中获取Bean（getBean方法）</strong></p>
</blockquote>
<p><strong>问题：业务层中仍然是使用new创建对象，仍然耦合，那么如何解耦合呢？</strong></p>
<h3 id="DI入门案例"><a href="#DI入门案例" class="headerlink" title="DI入门案例"></a>DI入门案例</h3><blockquote>
<p>思路分析：<br>1.基于IoC管理bean<br>2.Service使用new形式创建的Dao对象是否保留?（否）<br>3.Service中需要的Dao对象如何进入到service中?（提供方法）<br>4.Service与Dao间的关系如何描述?（配置）</p>
</blockquote>
<p>改变Service层实现代码如下<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"><span class="keyword">import</span> wang.service.Service;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="comment">// 删除业务层以new的方式创建Dao对象</span></span><br><span class="line">    <span class="comment">//private Dao dao = new DaoImpl();</span></span><br><span class="line">    <span class="keyword">private</span> Dao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service save() ...&quot;</span>);</span><br><span class="line">        dao.save();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 提供对应的set方法</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setDao</span><span class="params">(Dao dao)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.dao = dao;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>修改applicationContext.xml中配置：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Service&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.service.impl.ServiceImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--7.配置server与dao的关系--&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--property标签表示配置当前bean的属性</span></span><br><span class="line"><span class="comment">        name属性表示配置哪一个具体的属性</span></span><br><span class="line"><span class="comment">        ref属性表示参照哪一个bean--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;dao&quot;</span> <span class="attr">ref</span>=<span class="string">&quot;Dao&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<blockquote>
<p><strong>注意：name是上述的（private Dao dao;）语句中的变量名，ref是bean的名字。</strong></p>
</blockquote>
<p>运行结果与上述一样：<br><img src="https://wang-nine.cn/images/SSM01-05DI.png" alt="SSM01-05DI"></p>
<p><strong>综上：可以分为三步</strong></p>
<blockquote>
<p>1.<strong>删除以new的形式创建对象的代码</strong></p>
<p>2.<strong>提供对应的Set方法</strong></p>
<p>3.<strong>配置Service与Dao之间的关系</strong></p>
</blockquote>
<p><strong>注意在Bean标签中还可以进行以下的配置：</strong></p>
<p><strong>属性name：定义Bean的别名</strong></p>
<p><strong>属性scope：定义作用范围 singleton（默认，单例）  prototype（非单例）</strong></p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM02-Spring中Bean的实例化与依赖注入</title>
    <url>/posts/10302.html</url>
    <content><![CDATA[<p>详细的描述了Spring中Bean的实例化与依赖注入。<br><span id="more"></span></p>
<h3 id="Bean的实例化"><a href="#Bean的实例化" class="headerlink" title="Bean的实例化"></a>Bean的实例化</h3><h4 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h4><p>Spring创建Bean的时候调用无参构造。（有参构造会报错，私有无参也可以，底层使用了反射）</p>
<p>注意：Spring中的报错从下向上看，直到找到有用的信息。</p>
<p>注意：若不存在无参构造方法，会抛出异常：BeanCreationException</p>
<p>添加无参构造后：<br>运行结果：<br><img src="https://wang-nine.cn/images/SSM02-01%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95.png" alt="SSM02-01构造方法"></p>
<h4 id="静态工厂"><a href="#静态工厂" class="headerlink" title="静态工厂"></a>静态工厂</h4><p>创建对象不需要自己new，创建一个工厂创建对象达到解耦的效果</p>
<p>样例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"><span class="keyword">import</span> wang.dao.impl.DaoImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoFactory</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Dao <span class="title function_">getDao</span><span class="params">()</span> &#123;</span><br><span class="line">    	System.out.println(<span class="string">&quot;factory set up ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件添加如下代码：<br><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;daoFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.factory.DaoFactory&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getDao&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>主函数：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App3</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">Dao</span> <span class="variable">dao</span> <span class="operator">=</span> (Dao) ctx.getBean(<span class="string">&quot;daoFactory&quot;</span>);</span><br><span class="line">        dao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/SSM02-02%E9%9D%99%E6%80%81%E5%B7%A5%E5%8E%82.png" alt="SSM02-02静态工厂"></p>
<h4 id="实例工厂"><a href="#实例工厂" class="headerlink" title="实例工厂"></a>实例工厂</h4><p>工厂代码同上</p>
<p>配置文件修改为如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;daoFactorytemp&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.factory.DaoFactory&quot;</span>/&gt;</span>                 <span class="comment">&lt;!-- 创建工厂bean --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;daoFactory&quot;</span> <span class="attr">factory-bean</span>=<span class="string">&quot;daoFactorytemp&quot;</span> <span class="attr">factory-method</span>=<span class="string">&quot;getDao&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- factory-bean指定工厂bean --&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong>第一行为一个无用的bean，改良后即为第四种方法</strong></p>
<p>主函数不变</p>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/SSM02-03FactoryBean.png" alt="SSM02-03FactoryBean"></p>
<h4 id="FactoryBean（重要！）"><a href="#FactoryBean（重要！）" class="headerlink" title="FactoryBean（重要！）"></a>FactoryBean（重要！）</h4><p><strong>在第三种方法存在两个问题</strong><br><strong>一、factory-bean属性使用时会创建一个无用的Bean</strong><br><strong>二、factory-method属性方法名不固定，非动态实现</strong></p>
<p>因此，对此方法做了改良</p>
<p>factory实现一个接口FactoryBean<T> </p>
<p>工厂代码</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.factory;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.FactoryBean;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"><span class="keyword">import</span> wang.dao.impl.DaoImpl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoFactoryBean</span> <span class="keyword">implements</span> <span class="title class_">FactoryBean</span>&lt;Dao&gt; &#123;</span><br><span class="line">    <span class="comment">// 代替原始实例工厂创建对象的方法</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Dao <span class="title function_">getObject</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">DaoImpl</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 得到Bean的类型</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> Class&lt;?&gt; getObjectType() &#123;</span><br><span class="line">        <span class="keyword">return</span> Dao.class;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 设置Bean是否单例子，return true为单例，false为非单例</span></span><br><span class="line">    <span class="comment">// 该方法一般不重写</span></span><br><span class="line">    <span class="comment">/*@Override</span></span><br><span class="line"><span class="comment">    public boolean isSingleton() &#123;</span></span><br><span class="line"><span class="comment">        return true;</span></span><br><span class="line"><span class="comment">    &#125;*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件修改为如下代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;daoFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.factory.DaoFactoryBean&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>主函数不变</p>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/SSM02-03FactoryBean.png" alt="SSM02-03FactoryBean"></p>
<h4 id="补充：Bean的生命周期"><a href="#补充：Bean的生命周期" class="headerlink" title="补充：Bean的生命周期"></a>补充：Bean的生命周期</h4><h5 id="控制生命周期"><a href="#控制生命周期" class="headerlink" title="控制生命周期"></a>控制生命周期</h5><h6 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h6><p>控制方法代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DaoImpl <span class="keyword">implements</span> <span class="title class_">Dao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao save ... &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao init ... &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao destroy ... &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置控制方法：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;Dao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.dao.impl.DaoImpl&quot;</span> <span class="attr">init-method</span>=<span class="string">&quot;init&quot;</span> <span class="attr">destroy-method</span>=<span class="string">&quot;destory&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<h6 id="方法二"><a href="#方法二" class="headerlink" title="方法二"></a>方法二</h6><p>实现InitializingBean, DisposableBean接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> DaoImpl <span class="keyword">implements</span> <span class="title class_">Dao</span>, InitializingBean, DisposableBean &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao save ... &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao init ... &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> <span class="keyword">throws</span> Exception &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao destroy ... &quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h5 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h5><blockquote>
<p><strong>初始化容器</strong><br>1.创建对象（内存分配）<br>2.执行构造方法<br>3.执行属性注入( set操作）<br>4.执行bean初始化方法</p>
<p><strong>使用bean</strong><br>1.行业务操作</p>
<p><strong>关闭/销毁容器</strong><br>1.执行bean销毁方法</p>
</blockquote>
<p>注：<strong>销毁的时机：</strong>容器关闭前触发bean的销毁<br>关闭容器方式：<br>手工关闭容器<br>ConfigurableApplicationContext接口close（）</p>
<p>操作注册关闭钩子，在虚拟机退出前先关闭容器再退出虚拟机<br>ConfigurableApplicationcontext接口registerShutdownHook （）操作</p>
<h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><h4 id="setter注入"><a href="#setter注入" class="headerlink" title="setter注入"></a>setter注入</h4><h5 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h5><p>详情见博客 SSM01-Spring中的Bean </p>
<blockquote>
<p>步骤如下<br>1.在bean中定义引用类型属性并提供可访问的set方法<br>2.配置中使用property标签ref属性注入引用类型对象</p>
</blockquote>
<h5 id="简单类型"><a href="#简单类型" class="headerlink" title="简单类型"></a>简单类型</h5><blockquote>
<p>步骤如下<br>1.在bean中定义引用类型属性并提供可访问的set方法<br>2.配置中使用property标签value属性注入简单类型数据</p>
</blockquote>
<h4 id="构造器注入"><a href="#构造器注入" class="headerlink" title="构造器注入"></a>构造器注入</h4><h5 id="引用类型（仅做了解）"><a href="#引用类型（仅做了解）" class="headerlink" title="引用类型（仅做了解）"></a>引用类型（仅做了解）</h5><blockquote>
<p>步骤如下<br>1.在bean中定义引用类型属性并提供可访问的构造方法<br>2.配置中使用constructor-arg标签ref属性注入引用类型对象</p>
</blockquote>
<h5 id="简单类型-1"><a href="#简单类型-1" class="headerlink" title="简单类型"></a>简单类型</h5><blockquote>
<p>步骤如下<br>1.在bean中定义引用类型属性并提供可访问的set方法<br>2.配置中使用property标签value属性注入简单类型数据<br>注意：<br>配置中使用constructor-arg标签type属性设置按形参类型注入<br>配置中使用constructor-arg标签index属性设置按形参位置注入</p>
</blockquote>
<h4 id="依赖注入方式的选择（总结自黑马程序员，侵删）"><a href="#依赖注入方式的选择（总结自黑马程序员，侵删）" class="headerlink" title="依赖注入方式的选择（总结自黑马程序员，侵删）"></a>依赖注入方式的选择（总结自黑马程序员，侵删）</h4><p>1.强制依赖使用构造器进行，使用setter注入有概率不进行注入导致null对象出现<br>2.可选依赖使用setter注入进行，灵活性强<br>3.Spring框架倡导使用构造器，第三方框架内部大多数采用构造器注入的形式进行数据初始化，相对严谨<br>4.如果有必要可以两者同时使用，使用构造器注入完成强制依赖的注入，使用setter注入完成可选依赖的注入<br>5.实际开发过程中还要根据实际情况分析，如果受控对象没有提供setter方法就必须使用构造器注入<br>6.自己开发的模块推荐使用setter注入</p>
<h4 id="自动装配（优先级低于setter注入与构造器注入）"><a href="#自动装配（优先级低于setter注入与构造器注入）" class="headerlink" title="自动装配（优先级低于setter注入与构造器注入）"></a>自动装配（优先级低于setter注入与构造器注入）</h4><p>IoC容器根据bean所依赖的资源在容器中自动查找并注入到bean中的过程称为自动装配</p>
<p>自动装配方式</p>
<h5 id="按类型（常用）（不能对简单类型装配）"><a href="#按类型（常用）（不能对简单类型装配）" class="headerlink" title="按类型（常用）（不能对简单类型装配）"></a>按类型（常用）（不能对简单类型装配）</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;daoFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.dao.impl.DaoImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byType&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：需要set方法</p>
<p>注意：按类型（byType）时，同类型的应该只有一个bean，否则分不清。</p>
<h5 id="按名称-set方法第一个字母改为小写的名称，即标椎的变量名"><a href="#按名称-set方法第一个字母改为小写的名称，即标椎的变量名" class="headerlink" title="按名称(set方法第一个字母改为小写的名称，即标椎的变量名)"></a>按名称(set方法第一个字母改为小写的名称，即标椎的变量名)</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;daoFactory&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.dao.impl.DaoImpl&quot;</span> <span class="attr">autowire</span>=<span class="string">&quot;byName&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：因为变量名与byName耦合度高，不建议使用。</p>
<h5 id="按构造方法"><a href="#按构造方法" class="headerlink" title="按构造方法"></a>按构造方法</h5><h4 id="集合注入（主要学习格式）"><a href="#集合注入（主要学习格式）" class="headerlink" title="集合注入（主要学习格式）"></a>集合注入（主要学习格式）</h4><p>Dao接口</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">DataDao</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Dao实现</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> wang.dao.DataDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DataDaoImpl</span> <span class="keyword">implements</span> <span class="title class_">DataDao</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] array;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; list;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; set;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Map&lt;String,String&gt; map;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Properties properties;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setArray</span><span class="params">(<span class="type">int</span>[] array)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.array = array;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setList</span><span class="params">(List&lt;String&gt; list)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.list = list;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setSet</span><span class="params">(Set&lt;String&gt; set)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.set = set;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setMap</span><span class="params">(Map&lt;String, String&gt; map)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.map = map;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setProperties</span><span class="params">(Properties properties)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.properties = properties;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;book dao save ...&quot;</span>);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历数组:&quot;</span> + Arrays.toString(array));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历List&quot;</span> + list);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Set&quot;</span> + set);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Map&quot;</span> + map);</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">&quot;遍历Properties&quot;</span> + properties);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">&quot;dataDao&quot;</span> <span class="attr">class</span>=<span class="string">&quot;wang.dao.impl.DataDaoImpl&quot;</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--数组注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;array&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>100<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>200<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>300<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--list集合注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;list&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>c++<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>python<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>php<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--set集合注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;set&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>python<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>java<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">value</span>&gt;</span>php<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--map集合注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;map&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span> <span class="attr">value</span>=<span class="string">&quot;china&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span> <span class="attr">value</span>=<span class="string">&quot;shanxi&quot;</span>/&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span> <span class="attr">value</span>=<span class="string">&quot;xian&quot;</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--Properties注入--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;properties&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;country&quot;</span>&gt;</span>china<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;province&quot;</span>&gt;</span>shanxi<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">&quot;city&quot;</span>&gt;</span>xian<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App6</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br><span class="line">        <span class="type">DataDao</span> <span class="variable">dataDao</span> <span class="operator">=</span> (DataDao) ctx.getBean(<span class="string">&quot;dataDao&quot;</span>);</span><br><span class="line">        dataDao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/SSM02-04%E9%9B%86%E5%90%88%E6%B3%A8%E5%85%A5.png" alt="SSM02-04集合注入"></p>
<h4 id="第三方资源注入"><a href="#第三方资源注入" class="headerlink" title="第三方资源注入"></a>第三方资源注入</h4><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><h4 id="两种加载容器的方式"><a href="#两种加载容器的方式" class="headerlink" title="两种加载容器的方式"></a>两种加载容器的方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>); <span class="comment">//推荐</span></span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">FileSystemXmlApplicationContext</span>(<span class="string">&quot;D:\\ssm\\ssm\\springtest\\springtest\\src\\main\\resources\\applicationContext.xml&quot;</span>)	<span class="comment">//绝对路径寻找</span></span><br></pre></td></tr></table></figure>
<h4 id="两种获取bean的方式"><a href="#两种获取bean的方式" class="headerlink" title="两种获取bean的方式"></a>两种获取bean的方式</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dao</span> <span class="variable">dao</span> <span class="operator">=</span> (DataDao) ctx.getBean(<span class="string">&quot;dao&quot;</span>);</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">Dao</span> <span class="variable">dao</span> <span class="operator">=</span> ctx.getBean(<span class="string">&quot;dao&quot;</span>, Dao.class);  <span class="comment">//多个同种类型报错</span></span><br></pre></td></tr></table></figure>
<h4 id="对比ApplicationContext和BeanFactory"><a href="#对比ApplicationContext和BeanFactory" class="headerlink" title="对比ApplicationContext和BeanFactory"></a>对比ApplicationContext和BeanFactory</h4><p>BeanFactory是顶级接口的Bean是延迟加载</p>
<p>ApplicationContext是子接口（常用）也可以延迟加载，在bean中加入参数 lazy-init=“true” 即可</p>
<h4 id="加载第三方Bean"><a href="#加载第三方Bean" class="headerlink" title="加载第三方Bean"></a>加载第三方Bean</h4><h4 id="加载Properties文件"><a href="#加载Properties文件" class="headerlink" title="加载Properties文件"></a>加载Properties文件</h4><p>步骤如下：</p>
<ol>
<li>开启Context命名空间</li>
<li>使用context加载properties文件</li>
<li>使用属性占位符${}读取properties配置文件中的属性</li>
</ol>
<p>样例代码如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            &quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--步骤--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--1.开启命名空间--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--2.使用context加载properties文件--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;xxxx.properties&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--3.使用属性占位符$&#123;&#125;读取properties配置文件中的属性--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">&quot;xxxx&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;xxxx&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123; 配置中的变量名称 &#125;&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意：加载时可以关闭系统属性，因为系统属性的优先级高于</p>
<p>注意：多个配置文件用逗号隔开</p>
<p>注意：专业的写法加载所有配置文件如下</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 加载properties文件标准格式 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">context:property-placeholder</span> <span class="attr">location</span>=<span class="string">&quot;classpath:*.properties&quot;</span> <span class="attr">system-properties-mode</span>=<span class="string">&quot;NEVER&quot;</span>/&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 从类路径或jar包中搜索并加载properties文件</span></span><br><span class="line"><span class="comment">&lt;context:property-placeholder location=&quot;classpath*:*.properties&quot; system-properties-mode=&quot;NEVER&quot;/&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="总结（来自黑马程序员，侵删）"><a href="#总结（来自黑马程序员，侵删）" class="headerlink" title="总结（来自黑马程序员，侵删）"></a>总结（来自黑马程序员，侵删）</h3><h4 id="容器相关"><a href="#容器相关" class="headerlink" title="容器相关"></a>容器相关</h4><p><img src="https://wang-nine.cn/images/SSM02-05%E5%AE%B9%E5%99%A8%E7%9B%B8%E5%85%B3.png" alt="SSM02-05容器相关"></p>
<h4 id="bean相关"><a href="#bean相关" class="headerlink" title="bean相关"></a>bean相关</h4><p><img src="https://wang-nine.cn/images/SSM02-06bean%E7%9B%B8%E5%85%B3.png" alt="SSM02-06bean相关"></p>
<h4 id="依赖注入相关"><a href="#依赖注入相关" class="headerlink" title="依赖注入相关"></a>依赖注入相关</h4><p><img src="https://wang-nine.cn/images/SSM02-07%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E7%9B%B8%E5%85%B3.png" alt="SSM02-07依赖注入相关"></p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM04-Spring整合MyBatis</title>
    <url>/posts/10304.html</url>
    <content><![CDATA[<p>详细的描述了Spring整合myBatis和Spring整合Junit。<br><span id="more"></span></p>
<h3 id="Spring整合myBatis"><a href="#Spring整合myBatis" class="headerlink" title="Spring整合myBatis"></a>Spring整合myBatis</h3><p>正常的mybatis核心代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">        </span><br><span class="line"><span class="comment">//----------------------------------------------------------------------------------------------------//</span></span><br><span class="line">        <span class="comment">// 1. 创建SqlSessionFactoryBuilder对象</span></span><br><span class="line">        <span class="type">SqlSessionFactoryBuilder</span> <span class="variable">sqlSessionFactoryBuilder</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBuilder</span>();</span><br><span class="line">        <span class="comment">// 2. 加载SqlMapConfig.xml配置文件</span></span><br><span class="line">        <span class="type">InputStream</span> <span class="variable">inputStream</span> <span class="operator">=</span> Resources.getResourceAsStream(<span class="string">&quot;SqlMapConfig.xml.bak&quot;</span>);</span><br><span class="line">        <span class="comment">// 3. 创建SqlSessionFactory对象</span></span><br><span class="line">        <span class="type">SqlSessionFactory</span> <span class="variable">sqlSessionFactory</span> <span class="operator">=</span> sqlSessionFactoryBuilder.build(inputStream);</span><br><span class="line"><span class="comment">//---------------------------------  一、初始化SqlSessionFactory对象   ----------------------------------//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 4. 获取SqlSession</span></span><br><span class="line">        <span class="type">SqlSession</span> <span class="variable">sqlSession</span> <span class="operator">=</span> sqlSessionFactory.openSession();</span><br><span class="line">        <span class="comment">// 5. 执行SqlSession对象执行查询，获取结果User</span></span><br><span class="line">        <span class="type">AccountDao</span> <span class="variable">accountDao</span> <span class="operator">=</span> sqlSession.getMapper(AccountDao.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------  二、获取连接，获取实现   --------------------------------------------//</span></span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountDao.findById(<span class="number">2</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------  三、获取数据层接口   -----------------------------------------------//</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 6. 释放资源</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//---------------------------------  四、关闭连接   ----------------------------------------------------//</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>那么上述的代码需要将那个核心对象放入IoC中进行管理呢 </p>
<p><strong>SqlSessionFactory</strong> 最核心</p>
<h4 id="原来的整合方法"><a href="#原来的整合方法" class="headerlink" title="原来的整合方法"></a>原来的整合方法</h4><p>xml配置：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="keyword">configuration</span></span></span><br><span class="line"><span class="meta">        <span class="keyword">PUBLIC</span> <span class="string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span></span><br><span class="line"><span class="meta">        <span class="string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span> <span class="attr">resource</span>=<span class="string">&quot;jdbc.properties&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.domain&quot;</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">typeAliases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">environments</span> <span class="attr">default</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">environment</span> <span class="attr">id</span>=<span class="string">&quot;mysql&quot;</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">transactionManager</span> <span class="attr">type</span>=<span class="string">&quot;JDBC&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">transactionManager</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dataSource</span> <span class="attr">type</span>=<span class="string">&quot;POOLED&quot;</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;driver&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.driver&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;url&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.url&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;username&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.username&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">&quot;password&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$&#123;jdbc.password&#125;&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dataSource</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">environment</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">environments</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mappers</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">&quot;com.itheima.dao&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mappers</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主函数：</p>
<p>即上述的mybatis核心代码</p>
<p><strong>注意：xml配置与配置类的写法一一对应，原来的配置文件被新的配置类所代替，如下位配置类。</strong></p>
<h4 id="更改后的"><a href="#更改后的" class="headerlink" title="更改后的"></a>更改后的</h4><p>配置类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> org.mybatis.spring.SqlSessionFactoryBean;</span><br><span class="line"><span class="keyword">import</span> org.mybatis.spring.mapper.MapperScannerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MybatisConfig</span> &#123;</span><br><span class="line">    <span class="comment">//定义bean，SqlSessionFactoryBean，用于产生SqlSessionFactory对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> SqlSessionFactoryBean <span class="title function_">sqlSessionFactory</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">        <span class="type">SqlSessionFactoryBean</span> <span class="variable">ssfb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">SqlSessionFactoryBean</span>();</span><br><span class="line">        ssfb.setTypeAliasesPackage(<span class="string">&quot;com.itheima.domain&quot;</span>);</span><br><span class="line">        ssfb.setDataSource(dataSource);</span><br><span class="line">        <span class="keyword">return</span> ssfb;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//定义bean，返回MapperScannerConfigurer对象</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> MapperScannerConfigurer <span class="title function_">mapperScannerConfigurer</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="type">MapperScannerConfigurer</span> <span class="variable">msc</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">MapperScannerConfigurer</span>();</span><br><span class="line">        msc.setBasePackage(<span class="string">&quot;com.itheima.dao&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> msc;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意在主配置类中添加当前配置类的扫描</p>
<p>注意：第二种方法中 pom.xml 新增两个坐标</p>
</blockquote>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> com.itheima.config.SpringConfig;</span><br><span class="line"><span class="keyword">import</span> com.itheima.domain.Account;</span><br><span class="line"><span class="keyword">import</span> com.itheima.service.AccountService;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App2</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">AccountService</span> <span class="variable">accountService</span> <span class="operator">=</span> ctx.getBean(AccountService.class);</span><br><span class="line"></span><br><span class="line">        <span class="type">Account</span> <span class="variable">ac</span> <span class="operator">=</span> accountService.findById(<span class="number">1</span>);</span><br><span class="line">        System.out.println(ac);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Spring整合Junit"><a href="#Spring整合Junit" class="headerlink" title="Spring整合Junit"></a>Spring整合Junit</h3><p>新增依赖</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">scope</span>&gt;</span>test<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>测试样例：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">package com.itheima.service;</span><br><span class="line"></span><br><span class="line">import com.itheima.config.SpringConfig;</span><br><span class="line">import org.junit.Test;</span><br><span class="line">import org.junit.runner.RunWith;</span><br><span class="line">import org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line">import org.springframework.test.context.ContextConfiguration;</span><br><span class="line">import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line">//设置类运行器</span><br><span class="line">@RunWith(SpringJUnit4ClassRunner.class)</span><br><span class="line">//设置Spring环境对应的配置类</span><br><span class="line">@ContextConfiguration(classes = SpringConfig.class)</span><br><span class="line">public class AccountServiceTest &#123;</span><br><span class="line">    //支持自动装配注入bean</span><br><span class="line">    @Autowired</span><br><span class="line">    private AccountService accountService;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testFindById()&#123; System.out.println(accountService.findById(1)); &#125;</span><br><span class="line"></span><br><span class="line">    @Test</span><br><span class="line">    public void testFindAll()&#123; System.out.println(accountService.findAll()); &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意两点</p>
<blockquote>
<ul>
<li><p>设置类运行器：@RunWith(SpringJUnit4ClassRunner.class)</p>
<p>  设置Spring环境对应的配置类：@ContextConfiguration(classes = SpringConfig.class)</p>
</li>
<li><p>想用什么用@Autowired自动注入即可</p>
</li>
</ul>
</blockquote>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM03-Spring的纯注解开发模式</title>
    <url>/posts/10303.html</url>
    <content><![CDATA[<p>详细的描述了Spring中的注解开发。<br><span id="more"></span></p>
<h3 id="注解开发定义Bean"><a href="#注解开发定义Bean" class="headerlink" title="注解开发定义Bean"></a>注解开发定义Bean</h3><h4 id="步骤："><a href="#步骤：" class="headerlink" title="步骤："></a>步骤：</h4><h5 id="1-使用-Component定义Bean"><a href="#1-使用-Component定义Bean" class="headerlink" title="1.使用@Component定义Bean"></a>1.使用@Component定义Bean</h5><p>以下两种方式都可以定义Bean</p>
<p>@Component(“Bean的名称”)</p>
<p>@Component </p>
<p>其中第一种方式可以使用 ctx.getBean(“名称”)</p>
<p>其中第二种方式只能使用 ctx.getBean(“类型.class”) 因为没有指定名称</p>
<h5 id="2-核心配置文件中通过组件扫描加载Bean"><a href="#2-核心配置文件中通过组件扫描加载Bean" class="headerlink" title="2.核心配置文件中通过组件扫描加载Bean"></a>2.核心配置文件中通过组件扫描加载Bean</h5><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;wang&quot;</span>/&gt;</span> <span class="comment">&lt;!-- 递归扫描 wang --&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4><p>Spring提供@Component注解的三个衍生注解</p>
<blockquote>
<p>@controller：用于表现层bean定义<br>@service：用于业务层bean定义.<br>@Repository：用于数据层bean定义</p>
</blockquote>
<p>样例代码：</p>
<p>impl实现类：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component(&quot;dao&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoImpl</span> <span class="keyword">implements</span> <span class="title class_">Dao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao save() ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>xml配置文件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=<span class="string">&quot;1.0&quot;</span> encoding=<span class="string">&quot;UTF-8&quot;</span>?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.springframework.org/schema/beans&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">&quot;http://www.springframework.org/schema/context&quot;</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="string"><span class="tag">           http://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="string"><span class="tag">            &quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">&quot;wang&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.ApplicationContext;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.support.ClassPathXmlApplicationContext;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">App4</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml.bak&quot;</span>);</span><br><span class="line">        <span class="type">Dao</span> <span class="variable">dao</span> <span class="operator">=</span> (Dao) ctx.getBean(<span class="string">&quot;dao&quot;</span>);</span><br><span class="line">        dao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>运行结果：</p>
<p><img src="https://wang-nine.cn/images/SSM03-01%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%AE%9A%E4%B9%89Bean%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="SSM03-01注解开发定义Bean运行结果"></p>
<h3 id="纯注解开发模式"><a href="#纯注解开发模式" class="headerlink" title="纯注解开发模式"></a>纯注解开发模式</h3><p>Spring3.0升级了纯注解开发模式，使用Java类替代配置文件，开启了Spring快速开发赛道</p>
<p><strong>如何取消配置文件呢，使用一个配置类来代替配置文件</strong></p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;wang&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意：</p>
<blockquote>
<p><strong>@ComponentScan(“wang”) 代替了中间的组件扫描器的功能</strong></p>
<p><strong>@Configuration代替了 xml 配置文件中的其他配置，如下图：</strong></p>
</blockquote>
<p><img src="https://wang-nine.cn/images/SSM03-02%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E4%BB%A3%E6%9B%BF.png" alt="SSM03-02纯注解开发代替"></p>
<p>注意：ComponentScan({“wang.xxx01”, “wang.xxx02”}) 可以扫描多个类</p>
<p>主函数中需要改变一行代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ClassPathXmlApplicationContext</span>(<span class="string">&quot;applicationContext.xml&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>改为：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">ApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br></pre></td></tr></table></figure>
<p>此时删除xml配置文件运行结果相同：</p>
<p><img src="https://wang-nine.cn/images/SSM03-03%E7%BA%AF%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91%E5%AE%9A%E4%B9%89Bean%E8%BF%90%E8%A1%8C%E7%BB%93%E6%9E%9C.png" alt="SSM03-03纯注解开发定义Bean运行结果"></p>
<h3 id="Bean的管理"><a href="#Bean的管理" class="headerlink" title="Bean的管理"></a>Bean的管理</h3><h4 id="Bean的作用范围"><a href="#Bean的作用范围" class="headerlink" title="Bean的作用范围"></a>Bean的作用范围</h4><blockquote>
<p><strong>@Scope(“prototype”)即可更改</strong></p>
</blockquote>
<h4 id="Bean的生命周期"><a href="#Bean的生命周期" class="headerlink" title="Bean的生命周期"></a>Bean的生命周期</h4><p>如下代码：</p>
<p>实现类：<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Scope;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.annotation.PostConstruct;</span><br><span class="line"><span class="keyword">import</span> javax.annotation.PreDestroy;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Scope(&quot;singleton&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">DaoImpl</span> <span class="keyword">implements</span> <span class="title class_">Dao</span> &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Dao save() ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PostConstruct</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">init</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;init() ... &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@PreDestroy</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">destroy</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;destroy() ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>主函数：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.AnnotationConfigApplicationContext;</span><br><span class="line"><span class="keyword">import</span> wang.config.SpringConfig;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">AppForAnnotation</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigApplicationContext</span>(SpringConfig.class);</span><br><span class="line">        <span class="type">Dao</span> <span class="variable">dao1</span> <span class="operator">=</span> ctx.getBean(Dao.class);</span><br><span class="line">        <span class="type">Dao</span> <span class="variable">dao2</span> <span class="operator">=</span> ctx.getBean(Dao.class);</span><br><span class="line">        System.out.println(dao1);</span><br><span class="line">        System.out.println(dao2);</span><br><span class="line">        ctx.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意关闭容器或关闭钩子可以看到销毁操作</p>
<p>运行结果如下：</p>
<p><img src="https://wang-nine.cn/images/SSM03-04bean%E7%9A%84%E7%AE%A1%E7%90%86.png" alt="SSM03-04bean的管理"></p>
<h3 id="注解开发依赖注入"><a href="#注解开发依赖注入" class="headerlink" title="注解开发依赖注入"></a>注解开发依赖注入</h3><blockquote>
<p><strong>@AutoWired</strong>   —&gt; 实现了引用类型的注入</p>
<p>注意：自动装配基于反射设计创建对象并<strong>暴力反射</strong>对应属性为私有属性初始化数据，因此无需提供setter方法</p>
<p>注意：自动装配建议使用<strong>无参构造方法</strong>创建对象（默认），如果不提供对应构造方法，请提供唯一的构造方法</p>
</blockquote>
<p>样例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> wang.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> wang.dao.Dao;</span><br><span class="line"><span class="keyword">import</span> wang.service.Service;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="meta">@Qualifier(&quot;dao&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> Dao dao;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service save() ...&quot;</span>);</span><br><span class="line">        dao.save();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p><strong>@Value(“变量值”)</strong>   —&gt; 实现了加单类型的注入</p>
</blockquote>
<p>简单的样例代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServiceImpl</span> <span class="keyword">implements</span> <span class="title class_">Service</span> &#123;</span><br><span class="line">    <span class="meta">@Value(&quot;wang&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> string name;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">save</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;Service save() ...&quot;</span> + name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>那么为什么不直接将name定义为“wang”呢？为什么还要多此一举呢？</strong></p>
<p>因为可以通过@Value注入properties</p>
<p>在配置类中加入如下注解</p>
<blockquote>
<p>@PropertySource({“xxx.properties”，“xxx.properties”})  <strong>注意：不允许使用通配符 </strong></p>
</blockquote>
<p>此时可以通过@Value(“${ 属性名 }”) 访问properties中的属性</p>
<h3 id="注解开发管理第三方Bean"><a href="#注解开发管理第三方Bean" class="headerlink" title="注解开发管理第三方Bean"></a>注解开发管理第三方Bean</h3><blockquote>
<p>@Bean 表示当前方法的返回值是一个Bean</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringConfig</span> &#123;</span><br><span class="line">    <span class="comment">//1.定义一个方法获得要管理的对象</span></span><br><span class="line">    <span class="comment">//2.添加@Bean，表示当前方法的返回值是一个bean</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="keyword">public</span> Datasource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>();</span><br><span class="line">        ds.setDriverClassName(<span class="string">&quot;com.mysq1.jdbc.Driver&quot;</span>);</span><br><span class="line">        ds.setUr1(<span class="string">&quot;jdbc:mysql://localhost:3306/spring_db&quot;</span>);</span><br><span class="line">        ds.setUsername(<span class="string">&quot;root&quot;</span>);</span><br><span class="line">        ds.setPassword(<span class="string">&quot;1234&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>写好当前配置文件后，在独立的配置类中导入当前配置类</p>
<blockquote>
<p>方法1.扫描式   @ComponentScan({“xxx.service”, “xxx.dao”, “xxx.config”})   不推荐</p>
<p>方法2.导入式   @Import(xxxconfig.class)   推荐，更为清晰</p>
</blockquote>
<h4 id="注入普通类型："><a href="#注入普通类型：" class="headerlink" title="注入普通类型："></a>注入普通类型：</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Value(&quot;com.mysql.jdbc.Driver&quot;)</span></span><br><span class="line"><span class="keyword">private</span> string driver;</span><br><span class="line"><span class="meta">@value(&quot;jdbc:mysq1://localhost:3306/spring_db&quot;)</span></span><br><span class="line"><span class="keyword">private</span> string url;</span><br><span class="line"><span class="meta">@Value(&quot;root&quot;)</span></span><br><span class="line"><span class="keyword">private</span> string userName;</span><br><span class="line"><span class="meta">@Value(&quot;1234&quot;)</span></span><br><span class="line"><span class="keyword">private</span> string password;</span><br></pre></td></tr></table></figure>
<p><strong>使用@Value注入</strong></p>
<h4 id="注入引用类型"><a href="#注入引用类型" class="headerlink" title="注入引用类型"></a>注入引用类型</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Datasource <span class="title function_">dataSource</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">DruidDataSource</span> <span class="variable">ds</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DruidDataSource</span>(Dao dao);</span><br><span class="line">    System.out.println(dao);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> <strong>直接在形参声明即可，自动注入</strong></p>
<h3 id="XML配置对比注解配置"><a href="#XML配置对比注解配置" class="headerlink" title="XML配置对比注解配置"></a>XML配置对比注解配置</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:left">功能</th>
<th style="text-align:left">XML配置</th>
<th style="text-align:left">注解配置</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">定义Bean</td>
<td style="text-align:left">bean标签<br>  • id属性<br>  • class属性</td>
<td style="text-align:left">@Component<br>  • @Controller<br>  • @Service<br>  • @Repository&lt;br&gt;@ComponentScan</td>
</tr>
<tr>
<td style="text-align:left">设置依赖注入</td>
<td style="text-align:left">setter注入（set方法）<br>  • 引用类型/简单类型<br>构造器注入（构造方法）<br>  • 引用类型/简单类型<br>自动装配</td>
<td style="text-align:left">@AutoWired<br>  • @Qualifier&lt;br&gt;@Value</td>
</tr>
<tr>
<td style="text-align:left">配置第三方Bean</td>
<td style="text-align:left">bean标签<br>静态工厂、实例工厂、FactoryBean</td>
<td style="text-align:left">@Bean</td>
</tr>
<tr>
<td style="text-align:left">作用范围</td>
<td style="text-align:left">• scope属性</td>
<td style="text-align:left">@Scope</td>
</tr>
<tr>
<td style="text-align:left">生命周期</td>
<td style="text-align:left">标椎接口<br>  • init-method<br>  • destroy-method</td>
<td style="text-align:left">@PostConstructor&lt;br&gt;@PreDestroy</td>
</tr>
</tbody>
</table>
</div>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM05-Spring中的AOP概念</title>
    <url>/posts/10305.html</url>
    <content><![CDATA[<p>详细的描述了Spring中的AOP概念。<br><span id="more"></span></p>
<h3 id="AOP简介"><a href="#AOP简介" class="headerlink" title="AOP简介"></a>AOP简介</h3><h4 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h4><p><strong>AOP(Aspect Oriented Programming)面向切面编程，一种编程范式，指导开发者如何组织程序结构</strong></p>
<p>​    <strong>OOP(object Oriented Programming)面向对象编程</strong></p>
<p><strong>作用：在不惊动原始设计的基础上为其进行功能增强</strong></p>
<p><strong>Spring理念：无入侵式/无侵入式</strong></p>
<h4 id="核心概念"><a href="#核心概念" class="headerlink" title="核心概念"></a>核心概念</h4><ol>
<li><p>连接点 ( JoinPoint )：程序执行过程中的任意位置，粒度为执行方法、抛出异常、设置变量等</p>
<ul>
<li>在SpringAoP中，理解为方法的执行</li>
</ul>
<ul>
<li>切入点 ( Pointcut )：匹配连接点的式子<ul>
<li>在springAoP中，一个切入点可以只描述一个具体方法，也可以匹配多个方法<ul>
<li>一个具体方法: com.itheima.dao包下的BookDao接口中的无形参无返回值的save方法</li>
<li>匹配多个方法:所有的save方法，所有的get开头的方法，所有以Dao结尾的接口中的任意方法，所有带有一个参数的方法</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p>通知(Advice) ：在切入点处执行的操作，也就是共性功能</p>
<ul>
<li>在SpringAOP中，功能最终以方法的形式呈现</li>
</ul>
</li>
<li><p>通知类∶定义通知的类</p>
</li>
<li><p>切面( Aspect )︰描述通知与切入点的对应关系</p>
</li>
</ol>
<p>样例（源自黑马程序员，<strong>侵删</strong>）</p>
<p><img src="https://wang-nine.cn/images/SSM04-01AOP%E6%A0%B7%E4%BE%8B.png" alt="SSM04-01AOP样例"></p>
<h3 id="AOP入门案例"><a href="#AOP入门案例" class="headerlink" title="AOP入门案例"></a>AOP入门案例</h3><p>案例设定:测定接口执行效率<br>简化设定:在接口执行前输出当前系统时间<br>开发模式:XML or <strong>注解</strong></p>
<p>思路分析∶</p>
<ol>
<li>导入坐标（ pom.xml )</li>
<li>制作连接点方法（原始操作，Dao接口与实现类）</li>
<li>制作共性功能（通知类与通知)</li>
<li>定义切入点</li>
<li>绑定切入点与通知关系（切面)</li>
</ol>
<p>基础代码样例（源自黑马程序员）：</p>
<ol>
<li>导入坐标</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.2.10.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.aspectj<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>aspectjweaver<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.9.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>切面类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(切入点表达式&quot;)</span></span><br><span class="line"><span class="meta">    private void pt()&#123;&#125;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">    @Around(&quot;pt()&quot;)</span></span><br><span class="line"><span class="meta">    public Object around(ProceedingJoinPoint pjp) throws Throwable &#123;</span></span><br><span class="line"><span class="meta">        System.out.println(&quot;------------------------------&quot;);</span></span><br><span class="line"><span class="meta">        Long startTime = System.currentTimeMillis();</span></span><br><span class="line"><span class="meta">        for (int i = 0 ; i&lt;10000 ; i++) &#123;</span></span><br><span class="line"><span class="meta">            //调用原始操作</span></span><br><span class="line"><span class="meta">            pjp.proceed();</span></span><br><span class="line"><span class="meta">        &#125;</span></span><br><span class="line"><span class="meta">        Long endTime = System.currentTimeMillis();</span></span><br><span class="line"><span class="meta">        Long totalTime = endTime-startTime;</span></span><br><span class="line"><span class="meta">        System.out.println(&quot;执行万次消耗时间：&quot; + totalTime + &quot;ms&quot;);</span></span><br><span class="line"><span class="meta">        return null;</span></span><br><span class="line"><span class="meta">    &#125;</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">&#125;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>主配置类</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">加上注解 <span class="meta">@EnableAspectJAutoProxy</span></span><br></pre></td></tr></table></figure>
<p>剩余的代码不变，例如Dao接口和实现类，主函数</p>
<p>以上步骤总结：</p>
<ol>
<li>导入AOP坐标</li>
<li>定义dao接口与实现类</li>
<li>定义通知类，制作通知</li>
<li>定义切入点         <strong>说明︰切入点定义依托一个不具有实际意义的方法进行，即无参数，无返回值，方法体无实际逻辑</strong></li>
<li>绑定切入点与通知关系，并指定通知添加到原始连接点的具体执行<strong>位置</strong></li>
<li>定义通知类受Spring容器管理，并定义当前类为切面类，即添加 <strong>@Component</strong> 和 <strong>@Aspect</strong></li>
<li>开启Spring对AOP注解驱动支持，即在主配置类添加 <strong>@EnableAspectJAutoProxy</strong></li>
</ol>
<h3 id="AOP工作流程"><a href="#AOP工作流程" class="headerlink" title="AOP工作流程"></a>AOP工作流程</h3><ol>
<li>Spring容器启动</li>
<li>读取所有切面配置中的切入点</li>
<li>初始化bean，判定bean对应的类中的方法是否匹配到任意切入点<ul>
<li>匹配失败：创建对象</li>
<li>匹配成功：创建原始对象（<strong>目标对象</strong>）的<strong>代理对象</strong></li>
</ul>
</li>
<li>获取bean的执行方法<ul>
<li>获取bean，调用方法并执行，完成操作</li>
<li>获取的bean是代理对象时，根据代理对象的运行模式运行原始方法与增强的内容，完成操作</li>
</ul>
</li>
</ol>
<ul>
<li>目标对象（Target ）：原始功能去掉共性功能对应的类产生的对象，这种对象是无法直接完成最终工作的</li>
<li>代理（Proxy）：目标对象无法直接完成工作，需要对其进行功能回填，通过原始对象的代理对象实现</li>
</ul>
<h3 id="AOP深入"><a href="#AOP深入" class="headerlink" title="AOP深入"></a>AOP深入</h3><h4 id="AOP的切入点表达式"><a href="#AOP的切入点表达式" class="headerlink" title="AOP的切入点表达式"></a>AOP的切入点表达式</h4><p>切入点∶要进行增强的方法<br>切入点表达式∶要进行增强的方法的描述方式</p>
<h5 id="语法格式"><a href="#语法格式" class="headerlink" title="语法格式"></a>语法格式</h5><p><strong>即可以对接口进行描述，也可以对实现类进行描述</strong></p>
<h6 id="切入点表达式标准格式"><a href="#切入点表达式标准格式" class="headerlink" title="切入点表达式标准格式"></a>切入点表达式标准格式</h6><p>动作关键字（访问修饰符 返回值.包名.类/接口名.方法名（参数）异常名)</p>
<blockquote>
<p>execution (public User com.xxx.service.UserService.findById (int))</p>
</blockquote>
<ul>
<li>动作关键字∶描述切入点的行为动作，例如execution表示执行到指定切入点</li>
<li>访问修饰符：public , private等，可以省略</li>
<li>返回值</li>
<li>包名</li>
<li>类/接口名</li>
<li>方法名</li>
<li>参数</li>
<li>异常名：方法定义中抛出指定异常，可以省略</li>
</ul>
<h6 id="可以使用通配符描述切入点，快速描述"><a href="#可以使用通配符描述切入点，快速描述" class="headerlink" title="可以使用通配符描述切入点，快速描述"></a>可以使用通配符描述切入点，快速描述</h6><ul>
<li><p>* ︰单个独立的任意符号，可以独立出现，也可以作为前缀或者后缀的匹配符出现</p>
<blockquote>
<p>execution (public <em> com.xxx.\</em>.UserService.find<em>(</em>))<br>匹配com.xxx包下的任意包中的UserService类或接口中所有find开头的带有一个参数的方法</p>
</blockquote>
</li>
<li><p>.. ：多个连续的任意符号，可以独立出现，常用于简化包名与参数的书写</p>
<blockquote>
<p>execution (public User com..UserService.findById (..) )<br>匹配com包下的任意包中的UserService类或接口中所有名称为findByld的方法</p>
</blockquote>
</li>
<li><p>+︰专用于匹配子类类型</p>
<pre><code>  execution(\* \*..\*Service+.\*(..))
</code></pre></li>
</ul>
<h6 id="切入点表达式的书写技巧"><a href="#切入点表达式的书写技巧" class="headerlink" title="切入点表达式的书写技巧"></a>切入点表达式的书写技巧</h6><ul>
<li>所有代码按照标准规范开发，否则以下技巧全部失效</li>
<li>描述切入点<strong>通常描述接口</strong>，而不描述实现类</li>
<li>访问控制修饰符针对接口开发均采用public描述（<strong>可省略访问控制修饰符描述</strong>）</li>
<li>返回值类型对于增删改类使用精准类型加速匹配，对于查询类使用*通配快速描述</li>
<li><strong>包名</strong>书写<strong>尽量不使用..匹配</strong>，效率过低，常用*做单个包描述匹配，或精准匹配</li>
<li><strong>接口名</strong>/类名书写名称与模块相关的<strong>采用*匹配</strong>，例如UserService书写成*Service，绑定业务层接口名</li>
<li><strong>方法名</strong>书写以<strong>动词进行精准匹配</strong>，名词采用*匹配，例如getByld书写成getBy*,selectAll书写成selectAll</li>
<li>参数规则较为复杂，根据业务方法灵活调整</li>
<li>通常<strong>不使用异常作为匹配规则</strong></li>
</ul>
<h3 id="AOP通知类型"><a href="#AOP通知类型" class="headerlink" title="AOP通知类型"></a>AOP通知类型</h3><p><strong>AOP通知描述了抽取的共性功能，根据共性功能抽取的位置不同，最终运行代码时要将其加入到合理的位置AOP通知共分为5种类型</strong></p>
<ul>
<li>前置通知   <strong>@Before</strong></li>
<li>后置通知   <strong>@After</strong></li>
<li>环绕通知（<strong>重点</strong>）   <strong>@Around</strong>   <strong>需要对原始操作进行调用</strong></li>
<li>返回后通知（了解）   <strong>@AfterReturning</strong>   正常运行完才会运行</li>
<li>抛出异常后通知（了解）   <strong>@AfterThrowing</strong>   抛出异常才会运行</li>
</ul>
<p>环绕通知对原始操作的调用样例（<strong>注意有返回值时需要返回原始操作的返回值</strong>）：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> <span class="keyword">throws</span> Throwable &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;around before advice ...&quot;</span>);</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> pjp.proceed();</span><br><span class="line">        System.out.println(<span class="string">&quot;around after advice ...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>@Around注意事项</strong></p>
<ol>
<li>环绕通知必须依赖形参ProceedingJoinPoint才能实现对原始方法的调用，进而实现原始方法调用前后同时添加通知</li>
<li>通知中如果未使用ProceedingJoinPoint对原始方法进行调用将跳过原始方法的执行</li>
<li>对原始方法的调用可以不接收返回值，通知方法设置成void即可，如果接收返回值，必须设定为Object类型</li>
<li>原始方法的返回值如果是void类型，通知方法的返回值类型可以设置成void，也可以设置成Object</li>
<li>由于无法预知原始方法运行后是否会抛出异常，因此环绕通知方法必须抛出Throwable对象</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="type">signature</span> <span class="variable">signature</span> <span class="operator">=</span> pjp.getsignature();	<span class="comment">//获取代理类和被代理类的信息。</span></span><br><span class="line">system.out.println(signature.getDeclaringTypeName());	<span class="comment">//获取原始方法的类名</span></span><br><span class="line">system.out.println(signature.getName());	<span class="comment">//获取原始方法的方法名</span></span><br></pre></td></tr></table></figure>
<h3 id="AOP通知获取数据"><a href="#AOP通知获取数据" class="headerlink" title="AOP通知获取数据"></a>AOP通知获取数据</h3><h4 id="获取参数"><a href="#获取参数" class="headerlink" title="获取参数"></a>获取参数</h4><p>获取切入点方法的参数</p>
<ul>
<li><p>JoinPoint :适用于前置、后置、返回后、抛出异常后通知</p>
</li>
<li><p>ProceedJointPoint :适用于环绕通知</p>
</li>
</ul>
<h4 id="获取返回值"><a href="#获取返回值" class="headerlink" title="获取返回值"></a>获取返回值</h4><p>获取切入点方法返回值</p>
<ul>
<li><p>返回后通知</p>
</li>
<li><p>环绕通知</p>
</li>
</ul>
<h4 id="获取异常"><a href="#获取异常" class="headerlink" title="获取异常"></a>获取异常</h4><p>获取切入点方法运行异常信息</p>
<ul>
<li><p>抛出异常后通知</p>
</li>
<li><p>环绕通知</p>
</li>
</ul>
<p>样例代码如下（来自黑马程序员，侵删）</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> com.itheima.aop;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.JoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.ProceedingJoinPoint;</span><br><span class="line"><span class="keyword">import</span> org.aspectj.lang.annotation.*;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="meta">@Aspect</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">MyAdvice</span> &#123;</span><br><span class="line">    <span class="meta">@Pointcut(&quot;execution(* com.itheima.dao.BookDao.findName(..))&quot;)</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">void</span> <span class="title function_">pt</span><span class="params">()</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//JoinPoint：用于描述切入点的对象，必须配置成通知方法中的第一个参数，可用于获取原始方法调用的参数</span></span><br><span class="line"><span class="comment">//    @Before(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">before</span><span class="params">(JoinPoint jp)</span> &#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        System.out.println(<span class="string">&quot;before advice ...&quot;</span> );</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//    @After(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">after</span><span class="params">(JoinPoint jp)</span> &#123;</span><br><span class="line">        Object[] args = jp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        System.out.println(<span class="string">&quot;after advice ...&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//ProceedingJoinPoint：专用于环绕通知，是JoinPoint子类，可以实现对原始方法的调用</span></span><br><span class="line"><span class="comment">//    @Around(&quot;pt()&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> Object <span class="title function_">around</span><span class="params">(ProceedingJoinPoint pjp)</span> &#123;</span><br><span class="line">        Object[] args = pjp.getArgs();</span><br><span class="line">        System.out.println(Arrays.toString(args));</span><br><span class="line">        args[<span class="number">0</span>] = <span class="number">666</span>;</span><br><span class="line">        <span class="type">Object</span> <span class="variable">ret</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ret = pjp.proceed(args);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">            t.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置返回后通知获取原始方法的返回值，要求returning属性值必须与方法形参名相同</span></span><br><span class="line">    <span class="meta">@AfterReturning(value = &quot;pt()&quot;,returning = &quot;ret&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterReturning</span><span class="params">(JoinPoint jp,String ret)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterReturning advice ...&quot;</span>+ret);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置抛出异常后通知获取原始方法运行时抛出的异常对象，要求throwing属性值必须与方法形参名相同</span></span><br><span class="line">    <span class="meta">@AfterThrowing(value = &quot;pt()&quot;,throwing = &quot;t&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">afterThrowing</span><span class="params">(Throwable t)</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;afterThrowing advice ...&quot;</span>+t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM06-Spring中的事务</title>
    <url>/posts/10306.html</url>
    <content><![CDATA[<p>详细的描述了Spring中的事务概念。<br><span id="more"></span></p>
<h3 id="事务的简介"><a href="#事务的简介" class="headerlink" title="事务的简介"></a>事务的简介</h3><p>事务作用：在数据层保障一系列的数据库操作同成功同失败<br>Spring事务作用：在数据层或业务层保障一系列的数据库操作同成功同失败</p>
<p>如何开启事务管理？</p>
<p>步骤如下：</p>
<ol>
<li>在业务层接口上添加Spring事务管理</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">xxxxx</span> &#123;</span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> xxx &#123;</span><br><span class="line">        代码体</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意事项</strong>：<br>Spring注解式事务通常添加在业务层接口中而不会添加到业务层实现类中，降低耦合<br>注解式事务可以添加到业务方法上表示当前方法开启事务，也可以添加到接口上表示当前接口所有方法开启事务</p>
<ol>
<li>设置事务管理器</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="keyword">public</span> PlatformTransactionManager <span class="title function_">transactionManager</span><span class="params">(DataSource dataSource)</span>&#123;</span><br><span class="line">	<span class="type">DataSourceTransactionManager</span> <span class="variable">ptm</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">DataSourceTransactionManager</span>();</span><br><span class="line">    ptm.setDataSource(dataSource);</span><br><span class="line">	<span class="keyword">return</span> ptm;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li><p>在主配置类中开启事务型驱动</p>
<p>添加如下注解：</p>
</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@EnableTransactionmanagement</span></span><br></pre></td></tr></table></figure>
<h3 id="Spring事务角色"><a href="#Spring事务角色" class="headerlink" title="Spring事务角色"></a>Spring事务角色</h3><p>事务角色</p>
<h4 id="事务管理员"><a href="#事务管理员" class="headerlink" title="事务管理员"></a>事务管理员</h4><p>发起事务方，在Spring中通常指代业务层开启事务的方法</p>
<h4 id="事务协调员"><a href="#事务协调员" class="headerlink" title="事务协调员"></a>事务协调员</h4><p>加入事务方，在Spring中通常指代数据层方法，也可以是业务层方法</p>
<h3 id="事务属性"><a href="#事务属性" class="headerlink" title="事务属性"></a>事务属性</h3><div class="table-container">
<table>
<thead>
<tr>
<th style="text-align:center">属性</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">实例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">readOnly</td>
<td style="text-align:center">设置是否为只读事务</td>
<td style="text-align:center">readOnly = true   只读事务</td>
</tr>
<tr>
<td style="text-align:center">timeout</td>
<td style="text-align:center">设置事务的超过时间</td>
<td style="text-align:center">timeout = -1   永不超时</td>
</tr>
<tr>
<td style="text-align:center">rollbackFor</td>
<td style="text-align:center">设置事务回滚异常(class)</td>
<td style="text-align:center">rollbackFor = (NullPointException.class)</td>
</tr>
<tr>
<td style="text-align:center">rollbackForClassName</td>
<td style="text-align:center">设置事务回滚异常(String)</td>
<td style="text-align:center">同上格式为字符串</td>
</tr>
<tr>
<td style="text-align:center">noRollbackFor</td>
<td style="text-align:center">设置事务不回滚异常(class)</td>
<td style="text-align:center">noRollbackFor = (NullPointException.class)</td>
</tr>
<tr>
<td style="text-align:center">noRollbackForClassName</td>
<td style="text-align:center">设置事务不回滚异常(String)</td>
<td style="text-align:center">同上格式为字符串</td>
</tr>
<tr>
<td style="text-align:center">propagation</td>
<td style="text-align:center">设置事务传播行为</td>
<td style="text-align:center">…</td>
</tr>
</tbody>
</table>
</div>
<p><strong>事务传播行为</strong>：事务协调员对事务管理员所携带事务的处理态度</p>
<p><img src="https://wang-nine.cn/images/SSM05-01%E4%BA%8B%E5%8A%A1%E4%BC%A0%E6%92%AD%E8%A1%8C%E4%B8%BA.png" alt="SSM05-01事务传播行为"></p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM07-SpringMVC的请求与响应</title>
    <url>/posts/10307.html</url>
    <content><![CDATA[<p>详细的描述了SpringMVC中的请求与响应<br><span id="more"></span></p>
<h3 id="SpringMVC概述"><a href="#SpringMVC概述" class="headerlink" title="SpringMVC概述"></a>SpringMVC概述</h3><p>SpringMVC是一种基于Java实现MVC模型的轻量级web框架</p>
<p>优点</p>
<ul>
<li>使用简单，开发便捷（相比于Servlet）</li>
<li>灵活性强</li>
</ul>
<h3 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h3><h4 id="样例代码"><a href="#样例代码" class="headerlink" title="样例代码"></a>样例代码</h4><ol>
<li>使用SpringMVC技术需要先导入SpringMIVC坐标与Servlet坐标</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;javax.servlet&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">3.1</span><span class="number">.0</span>&lt;/version&gt;</span><br><span class="line">  &lt;scope&gt;provided&lt;/scope&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">  &lt;groupId&gt;org.springframework&lt;/groupId&gt;</span><br><span class="line">  &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt;</span><br><span class="line">  &lt;version&gt;<span class="number">5.2</span><span class="number">.10</span>.RELEASE&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>
<ol>
<li>创建SpringMvc控制器类（等同于servlet功能）</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 2.定义Controller</span></span><br><span class="line"><span class="comment">// 2.1 使用Controller定义Bean</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line">    <span class="comment">// 2.2 设置当前操作的访问路径</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/save&quot;)</span></span><br><span class="line">    <span class="comment">// 2.3 设置当前操作的返回值类型</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">save</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;user save...&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;moudle&#x27; : &#x27;springmvc&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化SpringMVC环境(同Spring环境)，设定SpringMVC加载对应的bean</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 3.创建springmvc的配置文件，加载controller对应的Bean</span></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan(&quot;com.wang.controller&quot;)</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">SpringMvcConfig</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>初始化Servlet容器，加载SpringMVC环境，并设置SpringMVC技术处理的请求</li>
</ol>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 4.定义一个Servlet容器启动的配置类，在里面加载spring的配置</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainerInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载springmvc容器配置</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createServletApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        ctx.register(SpringMvcConfig.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置哪些请求归属springmvc处理</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//加载spring容器配置</span></span><br><span class="line">    <span class="keyword">protected</span> WebApplicationContext <span class="title function_">createRootApplicationContext</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="type">AnnotationConfigWebApplicationContext</span> <span class="variable">ctx</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">AnnotationConfigWebApplicationContext</span>();</span><br><span class="line">        ctx.register(SpringConfig.class);</span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述案例中用到的注解说明：</p>
<ul>
<li>@Controller</li>
</ul>
<blockquote>
<p>类注解，放置于SpringMVC控制器定义上方，作用为设定SpringMVC的核心控制器Bean</p>
</blockquote>
<ul>
<li>@RequestMapping</li>
</ul>
<blockquote>
<p>方法注解，放置于SpringMVC控制器方法上方，作用为设定当前控制器方法的请求访问路径</p>
</blockquote>
<ul>
<li>@ResponseBody</li>
</ul>
<blockquote>
<p>方法注解，放置于SpringMVC控制器方法上方，作用为设置当前控制器方法的响应内容为当前返回值，无需解析</p>
</blockquote>
<ul>
<li>@ComponentScan</li>
</ul>
<blockquote>
<p>属性1：excludeFilters：排除扫描路径中加载的bean，需要指定类别(type)与具体项(classes)</p>
<p>属性2：includeFilters：加载指定的bean，需要指定类别(type)与具体项(classes)</p>
</blockquote>
<h4 id="SpringMVC入门程序开发总结（1-N）"><a href="#SpringMVC入门程序开发总结（1-N）" class="headerlink" title="SpringMVC入门程序开发总结（1+N）"></a>SpringMVC入门程序开发总结（1+N）</h4><ul>
<li>一次性工作<ul>
<li>创建工程，设置服务器，加载工程</li>
<li>导入坐标</li>
<li>创建web容器启动类，加载SpringMVC配置，并设置SpringMVC请求拦截路径</li>
<li>SpringMvc核心配置类（设置配置类，扫描controller包，加载Controller控制器bean）</li>
</ul>
</li>
<li>多次工作<ul>
<li>定义处理请求的控制器类</li>
<li>定义处理请求的控制器方法，并配置映射路径（@RequestMapping）与返回json数据（@ResponseBody）</li>
</ul>
</li>
</ul>
<h4 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h4><p><strong>启动服务器初始化过程</strong></p>
<ol>
<li>服务器启动，执行ServletcontainersInitConfig类，初始化web容器</li>
<li>执行createServletApplicationcontext方法，创建了webApplicationContext对象</li>
<li>加载SpringMvcConfig</li>
<li>执行@ComponentScan加载对应的bean</li>
<li>加载UserController，每个@RequestMapping的名称对应一个具体的方法</li>
<li>执行getServletMappings方法，定义所有的请求都通过springMVC</li>
</ol>
<h4 id="单次请求过程"><a href="#单次请求过程" class="headerlink" title="单次请求过程"></a>单次请求过程</h4><ol>
<li>发送请求localhost/save</li>
<li>web容器发现所有请求都经过SpringMVC，将请求交给SpringMVC处理</li>
<li>解析请求路径/save</li>
<li>由/save匹配执行对应的方法save()</li>
<li>执行save()</li>
<li>检测到有@ResponseBody直接将save()方法的返回值作为响应求体返回给请求方</li>
</ol>
<h4 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h4><p>因为功能不同，如何避免Spring错误的加载到SpringMVC的bean？</p>
<p>加载Spring控制的bean的时候排除掉SpringMVC控制的bean</p>
<p>SpringMIVC相关bean(表现层bean)</p>
<p>Spring控制的bean</p>
<ul>
<li>业务bean (Service)</li>
<li>功能bean (DataSource等)</li>
</ul>
<p>SpringMVC相关bean加载控制</p>
<ul>
<li>SpringMVC加载的bean对应的包均在com.xxx.controller包内</li>
</ul>
<p>Spring相关bean加载控制</p>
<ul>
<li>方式一：Spring加载的bean设定扫描范围为com.xxx，排除掉controller包内的bean</li>
<li>方式二： Spring加载的bean设定扫描范围为精准范围，例如service包、dao包等</li>
<li>方式三：不区分Spring与SpringMVC的环境，加载到同一个环境中</li>
</ul>
<p>方式一如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(value = &quot;com.wang&quot;,</span></span><br><span class="line"><span class="meta">        excludeFilters = @ComponentScan.Filter(</span></span><br><span class="line"><span class="meta">                type = FilterType.ANNOTATION,</span></span><br><span class="line"><span class="meta">                classes = Controller.class</span></span><br><span class="line"><span class="meta">        ))</span></span><br></pre></td></tr></table></figure>
<p>方式二如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@ComponentScan(&#123;&quot;com.wang.service&quot;, &quot;com.wang.dao&quot;&#125;)</span></span><br></pre></td></tr></table></figure>
<p>注意：简化开发代码如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">ServletContainerInitConfig</span> <span class="keyword">extends</span> <span class="title class_">AbstractAnnotationConfigDispatcherServletInitializer</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Class</span>[]&#123;SpringMvcConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">String</span>[]&#123;<span class="string">&quot;/&quot;</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="请求"><a href="#请求" class="headerlink" title="请求"></a>请求</h3><h4 id="设置请求的映射路径"><a href="#设置请求的映射路径" class="headerlink" title="设置请求的映射路径"></a>设置请求的映射路径</h4><p>团队多人开发，每人设置不同的请求路径，冲突问题如何解决？</p>
<blockquote>
<p>设置模块名作为请求路径前缀</p>
</blockquote>
<p>@RequestMapping(“/xxx”)</p>
<blockquote>
<p>当写在类上方时，即为统计设置请求路径的前缀，类方法中的@RequestMapping会自动加上前缀</p>
</blockquote>
<p>PostMan发送get请求和post请求</p>
<p>get请求</p>
<p>普通参数：url地址传参，地址参数名与形参变量名相同，定义形参即可接收参数</p>
<p>post请求</p>
<p>普通参数：form表单post请求传参，表单参数名与形参变量名相同，定义形参即可接收参数</p>
<p>post请求中文乱码问题：</p>
<p>为web容器添加过滤器并指定字符集，Spring-web包中提供了专用的字符过滤器</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//乱码处理</span></span><br><span class="line"><span class="meta">@override</span></span><br><span class="line"><span class="keyword">protected</span> Filter[] getServletFilters()&#123;</span><br><span class="line">	<span class="type">CharacterEncodingFilter</span> <span class="variable">filter</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">CharacterEncodingFilter</span>();</span><br><span class="line">    filter.setEncoding(<span class="string">&quot;UTF-8&quot;</span>);</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">Filter</span>[](filter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="参数种类"><a href="#参数种类" class="headerlink" title="参数种类"></a>参数种类</h4><p>若传入的属性名与实体类中的属性名一致，则会自动放入实体类中 </p>
<p>样例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//请求参数</span></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通参数：请求参数与形参名称对应即可完成参数传递</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParam</span><span class="params">(String name ,<span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递 name ==&gt; &quot;</span>+name);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递 age ==&gt; &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;common param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//普通参数：请求参数名与形参名不同时，使用@RequestParam注解关联请求参数名称与形参名称之间的关系</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/commonParamDifferentName&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">commonParamDifferentName</span><span class="params">(<span class="meta">@RequestParam(&quot;name&quot;)</span> String userName , <span class="type">int</span> age)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递 userName ==&gt; &quot;</span>+userName);</span><br><span class="line">        System.out.println(<span class="string">&quot;普通参数传递 age ==&gt; &quot;</span>+age);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;common param different name&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//POJO参数：请求参数与形参对象中的属性对应即可完成参数传递</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/pojoParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pojo参数传递 user ==&gt; &quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//嵌套POJO参数：嵌套属性按照层次结构设定名称即可完成参数传递</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/pojoContainPojoParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pojoContainPojoParam</span><span class="params">(User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pojo嵌套pojo参数传递 user ==&gt; &quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo contain pojo param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//数组参数：同名请求参数可以直接映射到对应名称的形参数组对象中</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/arrayParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">arrayParam</span><span class="params">(String[] likes)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;数组参数传递 likes ==&gt; &quot;</span>+ Arrays.toString(likes));</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;array param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合参数：同名请求参数可以使用@RequestParam注解映射到对应名称的集合对象中作为数据</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listParam</span><span class="params">(<span class="meta">@RequestParam</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;集合参数传递 likes ==&gt; &quot;</span>+ likes);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合参数：json格式</span></span><br><span class="line">    <span class="comment">//1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc</span></span><br><span class="line">    <span class="comment">//2.使用@RequestBody注解将外部传递的json数组数据映射到形参的集合对象中作为数据</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listParamForJson&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;String&gt; likes)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;list common(json)参数传递 list ==&gt; &quot;</span>+likes);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list common for json param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//POJO参数：json格式</span></span><br><span class="line">    <span class="comment">//1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc</span></span><br><span class="line">    <span class="comment">//2.使用@RequestBody注解将外部传递的json数据映射到形参的实体类对象中，要求属性名称一一对应</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/pojoParamForJson&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">pojoParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> User user)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;pojo(json)参数传递 user ==&gt; &quot;</span>+user);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;pojo for json param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//集合参数：json格式</span></span><br><span class="line">    <span class="comment">//1.开启json数据格式的自动转换，在配置类中开启@EnableWebMvc</span></span><br><span class="line">    <span class="comment">//2.使用@RequestBody注解将外部传递的json数组数据映射到形参的保存实体类对象的集合对象中，要求属性名称一一对应</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/listPojoParamForJson&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">listPojoParamForJson</span><span class="params">(<span class="meta">@RequestBody</span> List&lt;User&gt; list)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;list pojo(json)参数传递 list ==&gt; &quot;</span>+list);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;list pojo for json param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//日期参数</span></span><br><span class="line">    <span class="comment">//使用@DateTimeFormat注解设置日期类型数据格式，默认格式yyyy/MM/dd</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/dataParam&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">dataParam</span><span class="params">(Date date,</span></span><br><span class="line"><span class="params">                            <span class="meta">@DateTimeFormat(pattern=&quot;yyyy-MM-dd&quot;)</span> Date date1,</span></span><br><span class="line"><span class="params">                            <span class="meta">@DateTimeFormat(pattern=&quot;yyyy/MM/dd HH:mm:ss&quot;)</span> Date date2)</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;参数传递 date ==&gt; &quot;</span>+date);</span><br><span class="line">        System.out.println(<span class="string">&quot;参数传递 date1(yyyy-MM-dd) ==&gt; &quot;</span>+date1);</span><br><span class="line">        System.out.println(<span class="string">&quot;参数传递 date2(yyyy/MM/dd HH:mm:ss) ==&gt; &quot;</span>+date2);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;&#123;&#x27;module&#x27;:&#x27;data param&#x27;&#125;&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><h5 id="普通的形参"><a href="#普通的形参" class="headerlink" title="普通的形参"></a>普通的形参</h5><p>若形参与请求参数名称相同，则会自动绑定</p>
<p>@RequestParam</p>
<blockquote>
<p>可以绑定请求参数与处理器方法形参之间的关系</p>
<p>参数：required:是否为必传参数    defaultValue:参数默认值</p>
</blockquote>
<h5 id="Pojo参数"><a href="#Pojo参数" class="headerlink" title="Pojo参数"></a>Pojo参数</h5><p>请求参数名与形参对象属性名相同，定义PO30类型形参即可接收参数</p>
<h5 id="嵌套的Pojo参数"><a href="#嵌套的Pojo参数" class="headerlink" title="嵌套的Pojo参数"></a>嵌套的Pojo参数</h5><p>请求参数名与形参对象属性名相同，按照对象层次结构关系即可接收嵌套POJo属性参数</p>
<h5 id="数组参数"><a href="#数组参数" class="headerlink" title="数组参数"></a>数组参数</h5><p>请求参数名与形参对象属性名相同且请求参数为多个，定义数组类型形参即可接收参数</p>
<h5 id="集合保存普通参数"><a href="#集合保存普通参数" class="headerlink" title="集合保存普通参数"></a>集合保存普通参数</h5><p>请求参数名与形参集合对象名相同且请求参数为多个，@RequestParam绑定参数关系</p>
<h5 id="json-数据参数"><a href="#json-数据参数" class="headerlink" title="json 数据参数"></a>json 数据参数</h5><p>四个步骤：</p>
<ol>
<li>pom.xml中添加json坐标</li>
</ol>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jackson-databind<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.9.0<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>
<ol>
<li>主配置类中加入注解</li>
</ol>
<p>@EnableWebMvc</p>
<blockquote>
<p>开启由json对象装换位对象的功能</p>
</blockquote>
<ol>
<li>postman中传入参数</li>
<li>在参数前面加上@RequestBody</li>
</ol>
<ul>
<li>json数组</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span><span class="string">&quot;game&quot;</span><span class="punctuation">,</span><span class="string">&quot;music&quot;</span><span class="punctuation">,</span><span class="string">&quot;hobby&quot;</span><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<ul>
<li>json对象(Pojo)</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">	<span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;wang&quot;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">15</span><span class="punctuation">,</span></span><br><span class="line">	<span class="attr">&quot;address&quot;</span><span class="punctuation">:</span><span class="punctuation">&#123;</span></span><br><span class="line">		<span class="attr">&quot;province&quot;</span><span class="punctuation">:</span><span class="string">&quot;beijing&quot;</span><span class="punctuation">,</span></span><br><span class="line">        <span class="attr">&quot;city&quot;</span><span class="punctuation">:</span><span class="string">&quot;beijing&quot;</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">&#125;</span></span><br></pre></td></tr></table></figure>
<ul>
<li>json数组(Pojo)</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">[</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;wang&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">9</span><span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="punctuation">&#123;</span><span class="attr">&quot;name&quot;</span><span class="punctuation">:</span><span class="string">&quot;nine&quot;</span><span class="punctuation">,</span><span class="attr">&quot;age&quot;</span><span class="punctuation">:</span><span class="number">99</span><span class="punctuation">&#125;</span></span><br><span class="line"><span class="punctuation">]</span></span><br></pre></td></tr></table></figure>
<h5 id="RequestBody与-RequestParam区别"><a href="#RequestBody与-RequestParam区别" class="headerlink" title="@RequestBody与@RequestParam区别"></a>@RequestBody与@RequestParam区别</h5><ul>
<li><p>区别</p>
<ul>
<li><p>@RequestParam用于接收url地址传参，表单传参【application/x-www-form-urlencoded】</p>
</li>
<li><p>@RequestBody用于接收json数据【application/json】</p>
</li>
</ul>
</li>
<li><p>应用</p>
<ul>
<li>后期开发中，发送json格式数据为主，@RequestBody应用较广</li>
<li>如果发送非json格式数据，选用@Requestparam接收请求参数</li>
</ul>
</li>
</ul>
<h4 id="日期格式参数"><a href="#日期格式参数" class="headerlink" title="日期格式参数"></a>日期格式参数</h4><p>@DateTimeFormat(patter=“yyyy-MM-dd”)</p>
<blockquote>
<p>指定日期的格式</p>
</blockquote>
<h5 id="类型转换器"><a href="#类型转换器" class="headerlink" title="类型转换器"></a>类型转换器</h5><ul>
<li>Convert接口</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Converter</span>&lt;S, T&gt; &#123;</span><br><span class="line">    <span class="meta">@Nullable</span></span><br><span class="line">    T <span class="title function_">convert</span><span class="params">(S var1)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="响应"><a href="#响应" class="headerlink" title="响应"></a>响应</h3><ul>
<li>响应页面</li>
<li>响应数据<ul>
<li>文本数据</li>
<li>json数据</li>
</ul>
</li>
</ul>
<p>样例代码：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">UserController</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应页面/跳转页面</span></span><br><span class="line">    <span class="comment">//返回值为String类型，设置返回值为页面名称，即可实现页面跳转</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toJumpPage&quot;)</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toJumpPage</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;跳转页面&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;page.jsp&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应文本数据</span></span><br><span class="line">    <span class="comment">//返回值为String类型，设置返回值为任意字符串信息，即可实现返回指定字符串信息，需要依赖@ResponseBody注解</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toText&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">toText</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回纯文本数据&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;response text&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应POJO对象</span></span><br><span class="line">    <span class="comment">//返回值为实体类对象，设置返回值为实体类类型，即可实现返回对应对象的json数据，需要依赖@ResponseBody注解和@EnableWebMvc注解</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toJsonPOJO&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> User <span class="title function_">toJsonPOJO</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回json对象数据&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user.setName(<span class="string">&quot;itcast&quot;</span>);</span><br><span class="line">        user.setAge(<span class="number">15</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//响应POJO集合对象</span></span><br><span class="line">    <span class="comment">//返回值为集合对象，设置返回值为集合类型，即可实现返回对应集合的json数组数据，需要依赖@ResponseBody注解和@EnableWebMvc注解</span></span><br><span class="line">    <span class="meta">@RequestMapping(&quot;/toJsonList&quot;)</span></span><br><span class="line">    <span class="meta">@ResponseBody</span></span><br><span class="line">    <span class="keyword">public</span> List&lt;User&gt; <span class="title function_">toJsonList</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;返回json集合数据&quot;</span>);</span><br><span class="line">        <span class="type">User</span> <span class="variable">user1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user1.setName(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line">        user1.setAge(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">User</span> <span class="variable">user2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">User</span>();</span><br><span class="line">        user2.setName(<span class="string">&quot;Jerry&quot;</span>);</span><br><span class="line">        user2.setAge(<span class="number">12</span>);</span><br><span class="line"></span><br><span class="line">        List&lt;User&gt; userList = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;User&gt;();</span><br><span class="line">        userList.add(user1);</span><br><span class="line">        userList.add(user2);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> userList;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>@ResponseBody</p>
<blockquote>
<p>方法注解，SpringMVC控制器方法定义上方，设置当前控制器方法响应内容为当前返回值，无需解析</p>
</blockquote>
<p>内部是由类型转换器 HttpMessageConverter 接口发挥作用</p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM总览</title>
    <url>/posts/10300.html</url>
    <content><![CDATA[<h3 id="SSM01-Spring中的Bean"><a href="#SSM01-Spring中的Bean" class="headerlink" title="SSM01-Spring中的Bean"></a>SSM01-Spring中的Bean</h3><p><a href="https://wang-nine.cn/posts/10301.html">SSM01-Spring中的Bean</a></p>
<h3 id="SSM02-Spring中Bean的实例化与依赖注入"><a href="#SSM02-Spring中Bean的实例化与依赖注入" class="headerlink" title="SSM02-Spring中Bean的实例化与依赖注入"></a>SSM02-Spring中Bean的实例化与依赖注入</h3><p><a href="https://wang-nine.cn/posts/10302.html">SSM02-Spring中Bean的实例化与依赖注入</a></p>
<h3 id="SSM03-Spring的纯注解开发模式"><a href="#SSM03-Spring的纯注解开发模式" class="headerlink" title="SSM03-Spring的纯注解开发模式"></a>SSM03-Spring的纯注解开发模式</h3><p><a href="https://wang-nine.cn/posts/10303.html">SSM03-Spring的纯注解开发模式</a></p>
<h3 id="SSM04-Spring整合MyBatis"><a href="#SSM04-Spring整合MyBatis" class="headerlink" title="SSM04-Spring整合MyBatis"></a>SSM04-Spring整合MyBatis</h3><p><a href="https://wang-nine.cn/posts/10304.html">SSM04-Spring整合MyBatis</a></p>
<h3 id="SSM05-Spring中的AOP概念"><a href="#SSM05-Spring中的AOP概念" class="headerlink" title="SSM05-Spring中的AOP概念"></a>SSM05-Spring中的AOP概念</h3><p><a href="https://wang-nine.cn/posts/10305.html">SSM05-Spring中的AOP概念</a></p>
<h3 id="SSM06-Spring中的事务"><a href="#SSM06-Spring中的事务" class="headerlink" title="SSM06-Spring中的事务"></a>SSM06-Spring中的事务</h3><p><a href="https://wang-nine.cn/posts/10306.html">SSM06-Spring中的事务</a></p>
<h3 id="SSM07-SpringMVC的请求与响应"><a href="#SSM07-SpringMVC的请求与响应" class="headerlink" title="SSM07-SpringMVC的请求与响应"></a>SSM07-SpringMVC的请求与响应</h3><p><a href="https://wang-nine.cn/posts/10307.html">SSM07-SpringMVC的请求与响应</a></p>
<h3 id="SSM08-REST风格"><a href="#SSM08-REST风格" class="headerlink" title="SSM08-REST风格"></a>SSM08-REST风格</h3><p><a href="https://wang-nine.cn/posts/10308.html">SSM08-REST风格</a></p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>SSM08-REST风格</title>
    <url>/posts/10308.html</url>
    <content><![CDATA[<p>详细的描述了Spring中的REST开发风格<br><span id="more"></span></p>
]]></content>
      <categories>
        <category>SSM</category>
      </categories>
      <tags>
        <tag>Spring</tag>
      </tags>
  </entry>
  <entry>
    <title>博客搭建教程总览</title>
    <url>/posts/10001.html</url>
    <content><![CDATA[<h3 id="Hexo-Butterfly主题博客搭建01"><a href="#Hexo-Butterfly主题博客搭建01" class="headerlink" title="Hexo+Butterfly主题博客搭建01"></a>Hexo+Butterfly主题博客搭建01</h3><p><a href="https://wang-nine.cn/posts/10001.html">Hexo+Butterfly主题博客搭建01</a></p>
<h3 id="Hexo-Butterfly主题博客搭建02"><a href="#Hexo-Butterfly主题博客搭建02" class="headerlink" title="Hexo+Butterfly主题博客搭建02"></a>Hexo+Butterfly主题博客搭建02</h3><p><a href="https://wang-nine.cn/posts/10002.html">Hexo+Butterfly主题博客搭建02</a></p>
<h3 id="Hexo-Butterfly主题博客搭建03"><a href="#Hexo-Butterfly主题博客搭建03" class="headerlink" title="Hexo+Butterfly主题博客搭建03"></a>Hexo+Butterfly主题博客搭建03</h3><p><a href="https://wang-nine.cn/posts/10003.html">Hexo+Butterfly主题博客搭建03</a></p>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>博客更新文档</title>
    <url>/posts/1.html</url>
    <content><![CDATA[<p>[toc]</p>
<h3 id="新增或修改的文件结构"><a href="#新增或修改的文件结构" class="headerlink" title="新增或修改的文件结构"></a>新增或修改的文件结构</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">root</span><br><span class="line">│</span><br><span class="line">├─_config.yml(修改)</span><br><span class="line">│</span><br><span class="line">├─_config.butterfly.yml(修改)</span><br><span class="line">│</span><br><span class="line">└─themes</span><br><span class="line">    └─butterfly</span><br><span class="line">        ├─layout</span><br><span class="line">        │   ├─includes</span><br><span class="line">        │	│	├─custom</span><br><span class="line">        │	│	│	└─switch.pug(明暗切换动画)</span><br><span class="line">        │	│	│</span><br><span class="line">        │	│	├─header</span><br><span class="line">        │	│	│	└─menu_item.pug(修改，添加子菜单栏居中)</span><br><span class="line">        │	│	│</span><br><span class="line">        │   │   ├─wedget</span><br><span class="line">        │   │   │   ├─card_calendar.pug(新增写作日历)</span><br><span class="line">        │	│	│	├─card_webinfo.pug(新增写作日历)</span><br><span class="line">        │	│	│	└─index.pug(修改，添加写作日历)</span><br><span class="line">		│	│	│</span><br><span class="line">        │	│	└─rightside.pug(黑暗模式一图流)</span><br><span class="line">        │	│	</span><br><span class="line">        │	│	</span><br><span class="line">        │   ├─head.pug(新增，引入昼夜切换)	</span><br><span class="line">        │	├─rightside.pug(修改，昼夜切换)</span><br><span class="line">        │   └─sliderbar.pug</span><br><span class="line">        └─source</span><br><span class="line">            ├─css</span><br><span class="line">            │   ├─_layout</span><br><span class="line">            │   │   ├─calendar.styl(新增日历样式)</span><br><span class="line">            │   │   ├─footer.styl(修改，删除底部蓝条)</span><br><span class="line">            │   │   └─switch.styl(新增，明暗切换样式)</span><br><span class="line">            │   ├─custom</span><br><span class="line">            │   │   ├─background.css(黑暗模式一图流配置)</span><br><span class="line">            │	│	├─fontface.css(字体样式)</span><br><span class="line">            │	│	├─header_beautify.css(子菜单美化)</span><br><span class="line">            │	│	├─slideshow.css</span><br><span class="line">            │	│	├─starlight.css(星光背景)</span><br><span class="line">            │	│	└─twikoo_beautify(Twikoo评论美化)</span><br><span class="line">            │	├─FangZhengKaiTiJianTi-1.ttf(字体美化)</span><br><span class="line">            │	│</span><br><span class="line">            │   └─img(新增，主题图片)</span><br><span class="line">            │   </span><br><span class="line">            └─js</span><br><span class="line">            	└─custom</span><br><span class="line">            		├─foot.js(页脚修改)</span><br><span class="line">            		├─jquery.js(页脚修改支持)</span><br><span class="line">            		├─sakura.js(樱花背景动效)</span><br><span class="line">            		├─snow.js(雪花背景动效)</span><br><span class="line">            		├─snowflake.js(雪花背景动效)</span><br><span class="line">            		├─switch.js(切换明暗模式)</span><br><span class="line">            		└─universe.js(星空背景)</span><br></pre></td></tr></table></figure>
<h3 id="注意：abbrlink"><a href="#注意：abbrlink" class="headerlink" title="注意：abbrlink"></a>注意：abbrlink</h3><h4 id="100-开头为博客搭建相关"><a href="#100-开头为博客搭建相关" class="headerlink" title="100 开头为博客搭建相关"></a>100 开头为博客搭建相关</h4><h4 id="101-开头为JavaSE相关"><a href="#101-开头为JavaSE相关" class="headerlink" title="101 开头为JavaSE相关"></a>101 开头为JavaSE相关</h4><h4 id="102-开头为-JavaWeb相关"><a href="#102-开头为-JavaWeb相关" class="headerlink" title="102 开头为 JavaWeb相关"></a>102 开头为 JavaWeb相关</h4><h4 id="103-开头为ssm相关"><a href="#103-开头为ssm相关" class="headerlink" title="103 开头为ssm相关"></a>103 开头为ssm相关</h4><h4 id="104-开头为MySQL相关"><a href="#104-开头为MySQL相关" class="headerlink" title="104 开头为MySQL相关"></a>104 开头为MySQL相关</h4><h4 id="105开头为HTML-CSS相关"><a href="#105开头为HTML-CSS相关" class="headerlink" title="105开头为HTML+CSS相关"></a>105开头为HTML+CSS相关</h4><h4 id="2-开头为杂项"><a href="#2-开头为杂项" class="headerlink" title="2 开头为杂项"></a>2 开头为杂项</h4><h3 id="更新日志"><a href="#更新日志" class="headerlink" title="更新日志"></a>更新日志</h3><h4 id="2023-05-18"><a href="#2023-05-18" class="headerlink" title="2023-05-18"></a>2023-05-18</h4><h5 id="更新相关"><a href="#更新相关" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>无</li>
</ul>
<h5 id="bug相关"><a href="#bug相关" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>无</li>
</ul>
<h5 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h5><ul>
<li>初步创建github仓库，安装了nodejs和hexo，初始化了hexo博客</li>
</ul>
<h4 id="2023-05-19"><a href="#2023-05-19" class="headerlink" title="2023-05-19"></a>2023-05-19</h4><h5 id="更新相关-1"><a href="#更新相关-1" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>无</li>
</ul>
<h5 id="bug相关-1"><a href="#bug相关-1" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>无</li>
</ul>
<h5 id="杂项-1"><a href="#杂项-1" class="headerlink" title="杂项"></a>杂项</h5><p>采用next主题，进行了主题优化</p>
<h4 id="2023-05-20"><a href="#2023-05-20" class="headerlink" title="2023-05-20"></a>2023-05-20</h4><h5 id="更新相关-2"><a href="#更新相关-2" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>无</li>
</ul>
<h5 id="bug相关-2"><a href="#bug相关-2" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>无</li>
</ul>
<h5 id="杂项-2"><a href="#杂项-2" class="headerlink" title="杂项"></a>杂项</h5><p>放弃使用next主题，改用butterfly主题</p>
<h4 id="2023-05-21"><a href="#2023-05-21" class="headerlink" title="2023-05-21"></a>2023-05-21</h4><h5 id="更新相关-3"><a href="#更新相关-3" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>无</li>
</ul>
<h5 id="bug相关-3"><a href="#bug相关-3" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>无</li>
</ul>
<h5 id="杂项-3"><a href="#杂项-3" class="headerlink" title="杂项"></a>杂项</h5><p>计划将博客迁移到腾讯云上，购买了腾讯云服务器与域名，申请了ssl证书，在等待24小时后进行备案</p>
<h4 id="2023-05-22"><a href="#2023-05-22" class="headerlink" title="2023-05-22"></a>2023-05-22</h4><h5 id="更新相关-4"><a href="#更新相关-4" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>无</li>
</ul>
<h5 id="bug相关-4"><a href="#bug相关-4" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>无</li>
</ul>
<h5 id="杂项-4"><a href="#杂项-4" class="headerlink" title="杂项"></a>杂项</h5><p>进行备案，同时将空闲的服务器制作成了饥荒游戏的服务器</p>
<h4 id="2023-05-23"><a href="#2023-05-23" class="headerlink" title="2023-05-23"></a>2023-05-23</h4><h5 id="更新相关-5"><a href="#更新相关-5" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>无</li>
</ul>
<h5 id="bug相关-5"><a href="#bug相关-5" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>无</li>
</ul>
<h5 id="杂项-5"><a href="#杂项-5" class="headerlink" title="杂项"></a>杂项</h5><p>备案验证</p>
<h4 id="2023-05-24"><a href="#2023-05-24" class="headerlink" title="2023-05-24"></a>2023-05-24</h4><h5 id="更新相关-6"><a href="#更新相关-6" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li><p>主题优化，更改了博客的背景样式包括不同页面的背景，底部角标如运行时间等，背景透明度</p>
</li>
<li><p>添加了樱花特效与雪花特效，选择了樱花特效</p>
</li>
<li><p>添加了评论系统</p>
</li>
<li><p>添加了文章随机封面</p>
</li>
<li><p>更改了代码块显示</p>
</li>
<li><p>添加了本地搜索功能</p>
</li>
<li><p>修改了头像以及主页封面等</p>
</li>
<li><p>添加了文章版权信息</p>
</li>
<li><p>更改了图片放大查看</p>
</li>
<li><p>添加了相关文章功能</p>
</li>
<li><p>更改了侧边栏显示</p>
</li>
<li><p>更改了公告栏设置</p>
</li>
<li><p>更改了toc目录</p>
</li>
<li><p>更改了鼠标点击效果</p>
</li>
<li><p>更改了打字效果</p>
</li>
<li><p>更改了footer背景</p>
</li>
<li><p>添加了字数统计功能</p>
</li>
<li><p>更改了分享功能</p>
</li>
<li><p>更新了懒加载功能</p>
</li>
<li><p>在iconfont中添加了自定义图标</p>
</li>
</ul>
<h5 id="bug相关-6"><a href="#bug相关-6" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>无</li>
</ul>
<h5 id="杂项-6"><a href="#杂项-6" class="headerlink" title="杂项"></a>杂项</h5><ul>
<li>无</li>
</ul>
<h4 id="2023-05-25"><a href="#2023-05-25" class="headerlink" title="2023-05-25"></a>2023-05-25</h4><h5 id="更新相关-7"><a href="#更新相关-7" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>无</li>
</ul>
<h5 id="bug相关-7"><a href="#bug相关-7" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>无</li>
</ul>
<h5 id="杂项-7"><a href="#杂项-7" class="headerlink" title="杂项"></a>杂项</h5><p>备案成功，一整天在尝试将自己的博客由github迁移到腾讯云上，晚上成功，博客进行了cdn加速，在国内的访问速度也非常快了</p>
<h4 id="2023-05-26"><a href="#2023-05-26" class="headerlink" title="2023-05-26"></a>2023-05-26</h4><h5 id="更新相关-8"><a href="#更新相关-8" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>让域名被百度引擎收录</li>
<li>添加了博客日历功能</li>
<li>git贡献日历（已经删除）</li>
</ul>
<h5 id="bug相关-8"><a href="#bug相关-8" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>晚上发现博客更新后会出现cname失效的bug，在dns解析页面删除了存储桶的解析后bug解决（花了一晚上。。）</li>
</ul>
<h5 id="杂项-8"><a href="#杂项-8" class="headerlink" title="杂项"></a>杂项</h5><ul>
<li>知道了腾讯云CDN加速需要收费，不过收费较为便宜</li>
</ul>
<h4 id="2023-05-27"><a href="#2023-05-27" class="headerlink" title="2023-05-27"></a>2023-05-27</h4><h5 id="更新相关-9"><a href="#更新相关-9" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>添加了博客搜索功能</li>
<li>更新了评论功能，绑定了域名，新增部署，创建了定时任务，设置了安全域名</li>
<li>更新了评论功能，绑定了qq邮箱，绑定授权码</li>
<li>添加了评论回复显示身份功能</li>
<li>Valine评论功能废弃（改用Twikwoo。。。）</li>
</ul>
<h5 id="bug相关-9"><a href="#bug相关-9" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li><p>发现错误，baidu_url_submit配置的count过大，即git命令行出现{“error”:400,”message”:”over quota”}代码，更改count为20后无错误</p>
</li>
<li><p><strong>上述错误仍然出现，不知道什么原因。</strong></p>
</li>
<li><p>遇到了严重问题，github.io跳转失败，CDN加速无法添加A记录？（失败，github自带CDN加速，而自己的网站已经开启了CDN加速，除非使用子域名解决CNAME冲突？以后有需求再说吧，目前是国内wang-nine.cn访问，国外wang-nine.github.io）</p>
</li>
</ul>
<h5 id="杂项-9"><a href="#杂项-9" class="headerlink" title="杂项"></a>杂项</h5><ul>
<li>尝试更新valine，接入自己的域名，但是卡在了部署证书这一步，在论坛反应后等待</li>
<li>晚上发现已绑定（奇怪。）尝试更新评论系统吧</li>
<li>卡在了魔改valine的这一步，彻底放弃了，尝试更新更好的twikoo评论系统</li>
</ul>
<h4 id="2023-05-28"><a href="#2023-05-28" class="headerlink" title="2023-05-28"></a>2023-05-28</h4><h5 id="更新相关-10"><a href="#更新相关-10" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>更新twikoo评论功能</li>
<li>MongoDB申请存储管理挂载twikoo评论(暂时不予采用)</li>
<li>腾讯云开发赠送学生免费6个月(采用腾讯云开发对twikoo评论进行配置)</li>
<li>新增公式支持功能</li>
</ul>
<h5 id="bug相关-10"><a href="#bug相关-10" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>无</li>
</ul>
<h5 id="杂项-10"><a href="#杂项-10" class="headerlink" title="杂项"></a>杂项</h5><ul>
<li>无</li>
</ul>
<h4 id="2023-05-29"><a href="#2023-05-29" class="headerlink" title="2023-05-29"></a>2023-05-29</h4><h5 id="更新相关-11"><a href="#更新相关-11" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>更新Twikoo评论样式美化(在D:\Blog\themes\butterfly\source\css\custom中引入了css)</li>
<li>更新了分离搜索栏与菜单栏</li>
<li>更新了顶栏常驻</li>
<li>更新了文档支持公式</li>
</ul>
<h5 id="bug相关-11"><a href="#bug相关-11" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>顶部导航栏居中出了问题</li>
<li>xxxxxxxxxx57 1package com.itheima.aop;2​3import org.aspectj.lang.JoinPoint;4import org.aspectj.lang.ProceedingJoinPoint;5import org.aspectj.lang.annotation.<em>;6import org.springframework.stereotype.Component;7​8import java.util.Arrays;9​10@Component11@Aspect12public class MyAdvice {13    @Pointcut(“execution(</em> com.itheima.dao.BookDao.findName(..))”)14    private void pt(){}15​16    //JoinPoint：用于描述切入点的对象，必须配置成通知方法中的第一个参数，可用于获取原始方法调用的参数17//    @Before(“pt()”)18    public void before(JoinPoint jp) {19        Object[] args = jp.getArgs();20        System.out.println(Arrays.toString(args));21        System.out.println(“before advice …” );22    }23​24//    @After(“pt()”)25    public void after(JoinPoint jp) {26        Object[] args = jp.getArgs();27        System.out.println(Arrays.toString(args));28        System.out.println(“after advice …”);29    }30​31    //ProceedingJoinPoint：专用于环绕通知，是JoinPoint子类，可以实现对原始方法的调用32//    @Around(“pt()”)33    public Object around(ProceedingJoinPoint pjp) {34        Object[] args = pjp.getArgs();35        System.out.println(Arrays.toString(args));36        args[0] = 666;37        Object ret = null;38        try {39            ret = pjp.proceed(args);40        } catch (Throwable t) {41            t.printStackTrace();42        }43        return ret;44    }45​46    //设置返回后通知获取原始方法的返回值，要求returning属性值必须与方法形参名相同47    @AfterReturning(value = “pt()”,returning = “ret”)48    public void afterReturning(JoinPoint jp,String ret) {49        System.out.println(“afterReturning advice …”+ret);50    }51​52    //设置抛出异常后通知获取原始方法运行时抛出的异常对象，要求throwing属性值必须与方法形参名相同53    @AfterThrowing(value = “pt()”,throwing = “t”)54    public void afterThrowing(Throwable t) {55        System.out.println(“afterThrowing advice …”+t);56    }57}java</li>
<li>子菜单栏居中出了问题</li>
</ul>
<h5 id="杂项-11"><a href="#杂项-11" class="headerlink" title="杂项"></a>杂项</h5><ul>
<li>无</li>
</ul>
<h4 id="2023-05-30"><a href="#2023-05-30" class="headerlink" title="2023-05-30"></a>2023-05-30</h4><h5 id="更新相关-12"><a href="#更新相关-12" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>实现了子菜单栏居中的效果</li>
<li>删除了顶栏常驻效果</li>
<li>删除了分离搜索栏和菜单栏</li>
<li>将博客的字体改为了楷体</li>
<li>更新了博客中文章双栏显示（失败）</li>
<li>美化了博客中双栏显示的效果（失败）</li>
<li>修复了双栏显示后页码不居中的bug（失败）</li>
<li>增加了轮播图的功能（在文章配置中添加swiper_index属性，越大越先出现）</li>
</ul>
<h5 id="bug相关-12"><a href="#bug相关-12" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>阅读量和评论数一直加载中（已解决）</li>
</ul>
<h5 id="杂项-12"><a href="#杂项-12" class="headerlink" title="杂项"></a>杂项</h5><ul>
<li>无</li>
</ul>
<h4 id="2023-05-31"><a href="#2023-05-31" class="headerlink" title="2023-05-31"></a>2023-05-31</h4><h5 id="更新相关-13"><a href="#更新相关-13" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>取消了日历功能（取消）（加上了）</li>
<li>增加了夜晚模式下的流星背景特效</li>
<li>增加了首页轮播图</li>
<li>增加了一图流</li>
<li>增加了日夜切换动画</li>
<li>增加了首页轮播图</li>
</ul>
<h5 id="bug相关-13"><a href="#bug相关-13" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>首页透明度bug（使用一图流解决）</li>
<li>黑夜模式首页背景不同bug（使用一图流解决）</li>
<li>封面不加载</li>
</ul>
<h5 id="杂项-13"><a href="#杂项-13" class="headerlink" title="杂项"></a>杂项</h5><ul>
<li>无 </li>
</ul>
<h4 id="2023-06-01"><a href="#2023-06-01" class="headerlink" title="2023-06-01"></a>2023-06-01</h4><h5 id="更新相关-14"><a href="#更新相关-14" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>无</li>
</ul>
<h5 id="bug相关-14"><a href="#bug相关-14" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>博客第二页未更新（重新在cos中上传即可）</li>
</ul>
<h5 id="杂项-14"><a href="#杂项-14" class="headerlink" title="杂项"></a>杂项</h5><ul>
<li>无 </li>
</ul>
<h4 id="2023-06-02"><a href="#2023-06-02" class="headerlink" title="2023-06-02"></a>2023-06-02</h4><h5 id="更新相关-15"><a href="#更新相关-15" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>删除了轮播图</li>
</ul>
<h5 id="bug相关-15"><a href="#bug相关-15" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>无</li>
</ul>
<h5 id="杂项-15"><a href="#杂项-15" class="headerlink" title="杂项"></a>杂项</h5><ul>
<li>无 </li>
</ul>
<h4 id="2023-06-03"><a href="#2023-06-03" class="headerlink" title="2023-06-03"></a>2023-06-03</h4><h5 id="更新相关-16"><a href="#更新相关-16" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>无</li>
</ul>
<h5 id="bug相关-16"><a href="#bug相关-16" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>无</li>
</ul>
<h5 id="杂项-16"><a href="#杂项-16" class="headerlink" title="杂项"></a>杂项</h5><ul>
<li>无 </li>
</ul>
<h4 id="2023-06-04"><a href="#2023-06-04" class="headerlink" title="2023-06-04"></a>2023-06-04</h4><h5 id="更新相关-17"><a href="#更新相关-17" class="headerlink" title="更新相关"></a>更新相关</h5><ul>
<li>无</li>
</ul>
<h5 id="bug相关-17"><a href="#bug相关-17" class="headerlink" title="bug相关"></a>bug相关</h5><ul>
<li>无</li>
</ul>
<h5 id="杂项-17"><a href="#杂项-17" class="headerlink" title="杂项"></a>杂项</h5><ul>
<li>无 </li>
</ul>
]]></content>
      <categories>
        <category>博客搭建</category>
      </categories>
      <tags>
        <tag>博客搭建</tag>
      </tags>
  </entry>
  <entry>
    <title>关于</title>
    <url>/about/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>相册</title>
    <url>/gallery/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>资源</title>
    <url>/resources/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>分类</title>
    <url>/categories/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>峨眉山之行</title>
    <url>/gallery/%E8%83%8C%E6%99%AF/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
  <entry>
    <title>标签</title>
    <url>/tags/index.html</url>
    <content><![CDATA[]]></content>
  </entry>
</search>
